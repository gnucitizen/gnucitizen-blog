<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Agile Hacking - A Homegrown Telnet-based Portscanner</title><meta name="description" content="So here is the scenario: the attacker has limited access to a box and he/she needs to perform a portscan from it. However, he/she does not want to download any tools to the target system. There might be various reasons for not wanting to upload a portscanner to the box. Perhaps, the attacker wants to minimize the footprint."><meta property="name" content="Agile Hacking - A Homegrown Telnet-based Portscanner"><meta itemprop="name" content="Agile Hacking - A Homegrown Telnet-based Portscanner"><meta property="description" content="So here is the scenario: the attacker has limited access to a box and he/she needs to perform a portscan from it. However, he/she does not want to download any tools to the target system. There might be various reasons for not wanting to upload a portscanner to the box. Perhaps, the attacker wants to minimize the footprint."><meta itemprop="description" content="So here is the scenario: the attacker has limited access to a box and he/she needs to perform a portscan from it. However, he/she does not want to download any tools to the target system. There might be various reasons for not wanting to upload a portscanner to the box. Perhaps, the attacker wants to minimize the footprint."><meta property="image" content="https://www.gnucitizen.org/files/2008/05/homegrown_telnet_portscanner.png &quot;Homegrown Telnet Portscanner&quot;"><meta itemprop="image" content="https://www.gnucitizen.org/files/2008/05/homegrown_telnet_portscanner.png &quot;Homegrown Telnet Portscanner&quot;"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/agile-hacking-a-homegrown-telnet-based-portscanner/"><meta property="og:title" content="Agile Hacking - A Homegrown Telnet-based Portscanner"><meta property="og:description" content="So here is the scenario: the attacker has limited access to a box and he/she needs to perform a portscan from it. However, he/she does not want to download any tools to the target system. There might be various reasons for not wanting to upload a portscanner to the box. Perhaps, the attacker wants to minimize the footprint."><meta property="og:image" content="https://www.gnucitizen.org/files/2008/05/homegrown_telnet_portscanner.png &quot;Homegrown Telnet Portscanner&quot;"><meta name="twitter:title" content="Agile Hacking - A Homegrown Telnet-based Portscanner"><meta name="twitter:description" content="So here is the scenario: the attacker has limited access to a box and he/she needs to perform a portscan from it. However, he/she does not want to download any tools to the target system. There might be various reasons for not wanting to upload a portscanner to the box. Perhaps, the attacker wants to minimize the footprint."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://www.gnucitizen.org/files/2008/05/homegrown_telnet_portscanner.png &quot;Homegrown Telnet Portscanner&quot;"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">Agile Hacking - A Homegrown Telnet-based Portscanner</h1><div class="date">Sun, 11 May 2008 06:21:29 GMT</div><div class="author">by pagvac</div><div id="post-content"><p>So here is the scenario: the attacker has limited access to a box and he/she needs to perform a portscan from it. However, he/she does not want to download any tools to the target system. There might be various reasons for not wanting to upload a portscanner to the box. Perhaps, the attacker wants to minimize the footprint.</p>
<p>In my case, the reason why I had to come up with a solution to this problem is because I had to simulate an attack in which the attacker had gained access to a Internet-visible web server. In this case, I needed to perform a portscan of the backend database server and make sure that only required ports are visible (a customized mssql port in this case). For reasons that are irrelevant to this post, the customer could only give me <em>restricted access</em> (NOT root) to the web server via SSH.</p>
<p>I really didn&#39;t want to download a tool such as nmap and then compile it. In theory, I wouldn&#39;t be able to cause serious damage to the system since I was using a restricted user account. Even then, I always try to be as polite as possible with customers&#39; environments during security assessments, especially when it&#39;s a production system.</p>
<p>Anyway, my solution to this problem was to write a simple TCP portscanner in bash which glues around the telnet command which is present on most Unix/Linux distributions. Literally, all I&#39;m doing is looking for <em>Connected to</em> responses generated by telnet which tells us that a successful TCP connection was established (open port). Very vanilla and trivial stuff as you can see! Nevertheless, I accomplished what I wanted, which is to perform a portscan without having to download any tools and without requiring root privileges.</p>
<p>The following is the short version of our <a href="/blog/agile-hacking/">agile hacking</a> TCP portscanner which you can literally copy and paste on your shell (just change the value of the <code>HOST</code> variable to the IP address of the system you want to scan):</p>
<pre><code class="language-bash">HOST=127.0.0.1;<span class="keyword">for</span>((port=1;port&lt;=65535;++port));<span class="keyword">do</span> <span class="built_in">echo</span> -en <span class="string">"<span class="variable">$port</span> "</span>;<span class="keyword">if</span> <span class="built_in">echo</span> -en <span class="string">"open <span class="variable">$HOST</span> <span class="variable">$port</span>\nlogout\quit"</span> | telnet 2&gt;/dev/null | grep <span class="string">'Connected to'</span> &gt; /dev/null;<span class="keyword">then</span> <span class="built_in">echo</span> -en <span class="string">"\n\nport <span class="variable">$port</span>/tcp is open\n\n"</span>;<span class="keyword">fi</span>;<span class="keyword">done</span></code></pre>
<p>The following is a more elaborate version of our portscanner which supports scanning for either common or all ports. The list of common ports is read from the <code>/etc/services</code> file which is present on most Unix/Linux systems:</p>
<pre><code class="language-bash"><span class="meta">#!/bin/bash
</span>
<span class="comment"># telnet-based TCP portscanner</span>
<span class="comment"># By Adrian 'pagvac' Pastor | www.gnucitizen.org</span>

<span class="comment"># delay in seconds</span>

DELAY=0.001

<span class="keyword">if</span> [[ <span class="variable">$#</span> -ne 2 ]]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">"usage: <span class="variable">$0</span> &lt;mode&gt; &lt;host&gt;"</span>
    <span class="built_in">echo</span> -e <span class="string">"modes:\t1 - common TCP ports only"</span>
    <span class="built_in">echo</span> -e <span class="string">"\t2 - all TCP ports"</span>
    <span class="built_in">exit</span>
<span class="keyword">fi</span>

<span class="keyword">if</span> [[ <span class="variable">$1</span> -eq 1 ]]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">"scanning for the following common TCP ports on <span class="variable">$2</span> ..."</span>
    <span class="keyword">for</span> port <span class="keyword">in</span> `grep <span class="string">'/tcp'</span> /etc/services | cut -d <span class="string">'/'</span> -f 1 | cut -d <span class="string">' '</span> -f 2 | grep -v <span class="string">'#'</span> | awk <span class="string">'{print $2}'</span> | sort | uniq`
    <span class="keyword">do</span>
        <span class="built_in">echo</span> -en <span class="string">"<span class="variable">$port</span> "</span>
        <span class="keyword">if</span> <span class="built_in">echo</span> -en <span class="string">"open <span class="variable">$2</span> <span class="variable">$port</span>\nlogout\quit"</span> | telnet 2&gt;/dev/null | grep <span class="string">'Connected to'</span> &gt; /dev/null
        <span class="keyword">then</span>    
            <span class="built_in">echo</span> -en <span class="string">"\n\nport <span class="variable">$port</span>/tcp is open\n\n"</span>
        <span class="keyword">fi</span>
        sleep <span class="variable">$DELAY</span>
    <span class="keyword">done</span>
    <span class="built_in">echo</span> -en <span class="string">"\n"</span>
<span class="keyword">elif</span> [[ <span class="variable">$1</span> -eq 2 ]]
<span class="keyword">then</span>
    <span class="built_in">echo</span> <span class="string">"scanning for all TCP ports on <span class="variable">$2</span> ..."</span>
    <span class="keyword">for</span>((port=1;port&lt;=65535;++port))
    <span class="keyword">do</span>
        <span class="built_in">echo</span> -en <span class="string">"<span class="variable">$port</span> "</span>
        <span class="keyword">if</span> <span class="built_in">echo</span> -en <span class="string">"open <span class="variable">$2</span> <span class="variable">$port</span>\nlogout\quit"</span> | telnet 2&gt;/dev/null | grep <span class="string">'Connected to'</span> &gt; /dev/null
        <span class="keyword">then</span>    
            <span class="built_in">echo</span> -en <span class="string">"\n\nport <span class="variable">$port</span>/tcp is open\n\n"</span>
        <span class="keyword">fi</span>
        sleep <span class="variable">$DELAY</span>
    <span class="keyword">done</span>
    <span class="built_in">echo</span> -en <span class="string">"\n"</span>
<span class="keyword">fi</span></code></pre>
<p>Syntax follows:</p>
<pre><code class="language-bash">gnucitizen $ ./telnetps.sh
usage: ./telnetps.sh  &lt;mode&gt; &lt;host&gt;
modes:
        1 - common TCP ports only
        2 - all TCP ports</code></pre>
<div class="screen">![Homegrown Telnet Portscanner](/files/2008/05/homegrown_telnet_portscanner.png "Homegrown Telnet Portscanner")</div>

<p>I realize this is not a very elegant tool, but I hope you can see how it can be useful in certain scenarios!</p>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/be3b138352dc100c9459e612b275b413?s=256&amp;d=retro" alt="mindcorrosive"><span class="post-comment-author">mindcorrosive</span><div class="post-comment-content">hmm.. Isn't telnet one of the first services that every sysadmin turns off - for reasons all too known?</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/f432f91e7343dada3bfed35d7ceeb511?s=256&amp;d=retro" alt="defcon"><span class="post-comment-author">defcon</span><div class="post-comment-content">doesnt netcat do this? <code>nc -z host.example.com 20-30</code></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/93ea97e27eab21ae8e4c7c33a04b15fd?s=256&amp;d=retro" alt="Udi"><span class="post-comment-author">Udi</span><div class="post-comment-content">we use to do that 5 years ago. nice to see it still rocks .

yihaaaaa</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/192a78d487076b95fb3562ad601a1535?s=256&amp;d=retro" alt="Sandro Gauci"><span class="post-comment-author">Sandro Gauci</span><div class="post-comment-content">Such a tool can be useful ;) Most UNIX and linux systems come with perl builtin - even the older ones. So I'd make use of that instead if its available. Has the advantage of not relying on screen scraping telnet and not relying on having telnet on the system.
the idea:

<pre><code>use strict;
use IO::Socket;
my ($target,$remote,$results,$port,@ports);
unless (@ARGV > 0) { die "usage: $0 [ip]" }
$target = shift(@ARGV);
for ($port = 0; $port<65536; $port++)
{
    $remote = IO::Socket::INET->new(
                        Proto    => "tcp",
                        PeerAddr => $target,
                        PeerPort => $port,
                    );
    if ($remote) {print  "$port is open\n" };
}</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/0367b81839d31a5fa3d7bea79ef71b9e?s=256&amp;d=retro" alt="Adrian 'pagvac' Pastor"><span class="post-comment-author">Adrian 'pagvac' Pastor</span><div class="post-comment-content">@mindcorrosive: I see your point, however I usually find the telnet command available on many systems I audit.

@defcon: that's completely correct. This solution I proposed would be useful in cases in which netcat is not already installed on the system but telnet is. Also remember that in my case installing/downloading an additional tool was NOT an option.

@Udi: some solutions will always rock! I'm with you on that one :-D

@Sandro: Good to see you at GNUCITIZEN dude :) . Thanks a lot for another very useful solution. Another trick to use when needed. To me, it's all about knowing different tricks which come in handy in different scenarios! We'll definitely consider your solution for the Agile Hacking book! (you'll be credited of course).</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/192a78d487076b95fb3562ad601a1535?s=256&amp;d=retro" alt="Sandro Gauci"><span class="post-comment-author">Sandro Gauci</span><div class="post-comment-content">@pagvac: the more tricks the merrier :) re the book - that sounds great. looking forward to that

@mindcorrosive: the post refers to telnet the client rather than the daemon/server/service</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/e981d16e114902e23308d7371369d931?s=256&amp;d=retro" alt="Johann"><span class="post-comment-author">Johann</span><div class="post-comment-content">@mindcorrosive: Yes, telnet as a service, but this is using the telnet client. Not all sysadmins remove the telnet client.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/af275b336b54b308c86ba4c164bf3b89?s=256&amp;d=retro" alt="Shoaib Yousuf"><span class="post-comment-author">Shoaib Yousuf</span><div class="post-comment-content">Its more then 5 years old....Good to see refresh version of it by Adrian.

This is really worth using it if you are performing audit in restrictive mode and you see telnet option is available...Bingo!!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/0367b81839d31a5fa3d7bea79ef71b9e?s=256&amp;d=retro" alt="Adrian 'pagvac' Pastor"><span class="post-comment-author">Adrian 'pagvac' Pastor</span><div class="post-comment-content">I'll repeat it again in case it wasn't clear: my proposed homegrown port-scanner relies on the 'telnet' *CLIENT* (NOT server), which again is present on most Unix/Linux systems.

@Shoaib: I've never seen this specific implementation (telnet parser) of a portscanner in the public, but of course I'm not so naive to think this hasn't been done before! ;) All in all, this is just another trick of the trade which fits the Agile Hacking book project quite nicely IMHO.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c65f2a23045a747655b93b343d1f5000?s=256&amp;d=retro" alt="Venom23"><span class="post-comment-author">Venom23</span><div class="post-comment-content">Ok, again. Try this code. Does the same without telnet. It is still buggy but works. 

<pre><code>HOST=127.0.0.1;for((port=1;port&lt;=65535;++port));do echo -en "$port ";if exec 5&lt;&gt;/dev/tcp/$HOST/$port 2&gt;/dev/null;then echo -en "\n\nport $port/tcp is open\n\n";fi;done</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/0367b81839d31a5fa3d7bea79ef71b9e?s=256&amp;d=retro" alt="Adrian 'pagvac' Pastor"><span class="post-comment-author">Adrian 'pagvac' Pastor</span><div class="post-comment-content">@Venom23: I'm on a Debian-based system now (Ubuntu) which does not support /dev/tcp. However, it looks like your script should work on any systems that support /dev/tcp. Thanks for your solution to this problem!

Any other ideas guys? Any default clients with TCP capabilities (i.e. ftp) is a good candidate for a homegrown port-scanner which doesn't require root privileges to be run. Also, as Sandro mentioned, using any commonly-supported scripting environments such as Perl is another good candidate.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/af275b336b54b308c86ba4c164bf3b89?s=256&amp;d=retro" alt="Shoaib Yousuf"><span class="post-comment-author">Shoaib Yousuf</span><div class="post-comment-content">Adrian,

I totally agree. Another great piece of work from you guys. Keep it up!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">This is cool. I believe Ed Skoudis has done something similar to this on Windows....

Here is an alternative, though not as polished, using curl...

Open ports return this response to our stimulous sorry if line is wrapped:

<pre><code>  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  5242  100  5242    0     0  15489      0 --:--:-- --:--:-- --:--:--     0</code></pre>

close ports look like this:

<pre><code>scanning port 122...

curl: (7) couldn't connect to host</code></pre>

----------script-----------

<pre><code>## portscanner implimented with curl
#!/bin/bash

if [ $# -ne 1 ]; then
    echo 1&gt;&amp;2 "usage: $0  "
    echo 1&gt;&amp;2 "mode 1 = well known ports 1-1024"
    echo 1&gt;&amp;2 "mode 2 = all ports"
    exit 127
fi

case "$1" in
1)
LIMIT=1024
for ((a=1; a  /dev/null &gt; out
  cat out | grep -v "curl: (7) couldn't connect to host"
done;                           
;;
2)
LIMIT=65535
for ((a=1; a  /dev/null &gt; out
  cat out | grep -v "curl: (7) couldn't connect to host"
done;              
;;
esac</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c65f2a23045a747655b93b343d1f5000?s=256&amp;d=retro" alt="Venom23"><span class="post-comment-author">Venom23</span><div class="post-comment-content">Or let's use the wget command to perform the scan ;)

<pre><code>HOST=192.168.178.88;for((port=1;port&lt;=65535;++port));do echo -en "$port ";if wget -F -S -t 1 -T 1 -v -O banner.txt $HOST:$port 2&gt;&amp;1 | grep connected;then echo -en "\n\nport $port/tcp is open\n\n";cat banner.txt;fi;done</code></pre>

wget should also be available on most of the systems. And - the coolest - it does a "banner grabbing" as well. Nice, isn't it?</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Venom23: nicely done! I particularly like the banner grabbing ;-)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ed3de6ce3f881c547df0c9ec2b55be07?s=256&amp;d=retro" alt="maeh"><span class="post-comment-author">maeh</span><div class="post-comment-content">Here's a one for windows using netsh that just prints out any open ports it finds.

<pre><code>@ECHO OFF &amp; ECHO start &amp; (FOR /L %p IN (1,1,65535) DO (FOR /F "tokens=*" %a IN ('netsh diag connect iphost 127.0.0.1 %p ^| find /C /I "[NONE]"') DO ( IF %a == 0 echo %p))) &amp; ECHO stop &amp; @ECHO ON</code></pre>

It's rather slow since netsh seems to take quite a while to load, so you might want to narrow down the port range a bit ;&gt;.

What I found interesting is the message the "netsh diag connect iphost" command outputs: "Server appears to be running on port(s) [NONE]" which seems to suggest you could enter more than one port to connect to, but I could'nt find out how to do so.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/0367b81839d31a5fa3d7bea79ef71b9e?s=256&amp;d=retro" alt="Adrian 'pagvac' Pastor"><span class="post-comment-author">Adrian 'pagvac' Pastor</span><div class="post-comment-content">It's awesome to see so many solutions and implementations for on-the-fly portscanning. This is great guys, keep it coming!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/425b307120eb2cae2dbda9bb22690d3d?s=256&amp;d=retro" alt="Simon Stroh"><span class="post-comment-author">Simon Stroh</span><div class="post-comment-content">Here's a perl solution I just threw together, thought the ones presented here might be a tad slow when scanning all the ports, so I made this one multithreaded:  :-)

<pre><code>#!/usr/bin/perl
use IO::Socket;
@ARGV||die'usage: perl scanner.pl host [number of threads]';
($|,$h,$t)=(1,@ARGV,20);$p=65535/$t;
for$n(1..$t){
        pipe($r[$n],$w[$n]);next if fork;
        print IO::Socket::INET-&gt;new(PeerAddr=&gt;$h,PeerPort=&gt;$_)?"Port $_ open\n":''for($p*($n-1)...$p*$n-1);
        print{$w[$n]}'x';exit;
}
read($r[$_],$x,1)for(1..$t);</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">nice. this is quite neat actually.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/cda3633ce59fb6ba2ce123f9411760fc?s=256&amp;d=retro" alt="Broeisi"><span class="post-comment-author">Broeisi</span><div class="post-comment-content">Simon Stroh... Your perl script isn't working.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/e71ef99180c588da767cde951f604dbd?s=256&amp;d=retro" alt="NOVA"><span class="post-comment-author">NOVA</span><div class="post-comment-content">This is a script i wrote to demonstrate a sort of bounce technique i use :) its written in python which i am currently in love with :)

<pre><code>import socket
import getpass
import sys
import telnetlib

#Edit these
HOSTA = "78.32.236.185"
PasswordA = "Sch5636$\n"

HOSTB = "82.111.251.241"
PasswordB = "LLUcpe99\n"

HOSTC = "82.108.105.177"
PasswordC = "LLUcpe99\n"

PORT = "23"



#RAS Commands

jmp1 = "ip telnet "+HOSTB+" "+PORT+"\n"
jmp2 = "ip telnet "+HOSTC+" "+PORT+"\n" 

#Connect to 1st router.
tn = telnetlib.Telnet(HOSTA)
print tn.read_until("Password: ") 
tn.write(PasswordA)
print tn.read_until("ras&gt;")
tn.write(jmp1)

#Connect to second router.
print tn.read_until("Password: ")
tn.write(PasswordB)
print tn.read_until("ras&gt;")
tn.write(jmp2)

#Connect to target system.
print tn.read_until("Password: ")
tn.write(PasswordC)
print tn.read_until("ras&gt;")
tn.write(jmp3)

print tn.read_until("Password: ")
tn.write(PasswordC)
print tn.read_until("ras&gt;")</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/40aca19232b2e7b05ceff5a3256e49ca?s=256&amp;d=retro" alt="Simon Stroh"><span class="post-comment-author">Simon Stroh</span><div class="post-comment-content">Here's another one. This one is special, because it only uses bash builtins! No programs other than bash shells are called :-)

<pre><code>HOST=127.0.0.1;for p in {0..65535};do((bash -c "(&gt;/dev/tcp/$HOST/$p)" 2&gt; /dev/null &amp;&amp; echo open: $p)&amp;read -t0.1;kill $! 2&gt;/dev/null)2&gt;/dev/null;done</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/2da0a05e8aa3acfcb6e7ed1872b7661b?s=256&amp;d=retro" alt="Bob"><span class="post-comment-author">Bob</span><div class="post-comment-content">Would this be a correct three-liner to test single port connectivity (say to test for an install prerequisite with same restrictions)?

<pre><code>echo -en "open $HOST $PORT\nlogout\quit" | telnet 2&gt;/dev/null | grep 'Connected to' &gt; /dev/null
CONNECT_ERROR=$?
if[$CONNECT_ERROR]; then echo"no good"</code></pre></div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2021 <a href=""></a>. All rights reserved.</p></footer></body></html>