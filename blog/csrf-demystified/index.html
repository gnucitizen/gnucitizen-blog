<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>CSRF Demystified</title><meta name="description" content="Cross-Site Request Forgery has been all over the press recently since several major sites and web applications were plagued by exploits and uncovered vulnerabilities - including GMail, Google AdSense and many others. When talking to developers about CSRF there's mostly not that much knowledge and a lot of misconceptions and FUD. Sometimes the term CSRF hasn't even been heard of before. So, with this article, I will try to provide a basic explanation about the attack pattern itself, come up with several real word examples and finally summarize a list of things developers can do to protect their sites against CSRF attacks."><meta property="name" content="CSRF Demystified"><meta itemprop="name" content="CSRF Demystified"><meta property="description" content="Cross-Site Request Forgery has been all over the press recently since several major sites and web applications were plagued by exploits and uncovered vulnerabilities - including GMail, Google AdSense and many others. When talking to developers about CSRF there's mostly not that much knowledge and a lot of misconceptions and FUD. Sometimes the term CSRF hasn't even been heard of before. So, with this article, I will try to provide a basic explanation about the attack pattern itself, come up with several real word examples and finally summarize a list of things developers can do to protect their sites against CSRF attacks."><meta itemprop="description" content="Cross-Site Request Forgery has been all over the press recently since several major sites and web applications were plagued by exploits and uncovered vulnerabilities - including GMail, Google AdSense and many others. When talking to developers about CSRF there's mostly not that much knowledge and a lot of misconceptions and FUD. Sometimes the term CSRF hasn't even been heard of before. So, with this article, I will try to provide a basic explanation about the attack pattern itself, come up with several real word examples and finally summarize a list of things developers can do to protect their sites against CSRF attacks."><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fcsrf-demystified%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fcsrf-demystified%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/csrf-demystified/"><meta property="og:title" content="CSRF Demystified"><meta property="og:description" content="Cross-Site Request Forgery has been all over the press recently since several major sites and web applications were plagued by exploits and uncovered vulnerabilities - including GMail, Google AdSense and many others. When talking to developers about CSRF there's mostly not that much knowledge and a lot of misconceptions and FUD. Sometimes the term CSRF hasn't even been heard of before. So, with this article, I will try to provide a basic explanation about the attack pattern itself, come up with several real word examples and finally summarize a list of things developers can do to protect their sites against CSRF attacks."><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fcsrf-demystified%2F?w=1024"><meta name="twitter:title" content="CSRF Demystified"><meta name="twitter:description" content="Cross-Site Request Forgery has been all over the press recently since several major sites and web applications were plagued by exploits and uncovered vulnerabilities - including GMail, Google AdSense and many others. When talking to developers about CSRF there's mostly not that much knowledge and a lot of misconceptions and FUD. Sometimes the term CSRF hasn't even been heard of before. So, with this article, I will try to provide a basic explanation about the attack pattern itself, come up with several real word examples and finally summarize a list of things developers can do to protect their sites against CSRF attacks."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fcsrf-demystified%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">CSRF Demystified</h1><div class="date">Wed, 21 Nov 2007 10:22:34 GMT</div><div class="author">by mario-heiderich</div><div id="post-content"><p><a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">Cross-Site Request Forgery</a> has been all over the press recently since several major sites and web applications were plagued by exploits and uncovered vulnerabilities - including <a href="http://www.kb.cert.org/vuls/id/571584">GMail</a>, <a href="http://www.thespanner.co.uk/2007/09/27/google-adsense-csrf-hole/">Google AdSense</a> and many others. When talking to developers about CSRF there&#39;s mostly not that much knowledge and a lot of misconceptions and <a href="http://en.wikipedia.org/wiki/Fear%2C_uncertainty_and_doubt">FUD</a>. Sometimes the term CSRF hasn&#39;t even been heard of before. So, with this article, I will try to provide a basic explanation about the attack pattern itself, come up with several real word examples and finally summarize a list of things developers can do to protect their sites against CSRF attacks.</p>
<h2 id="what-is-csrf">What is CSRF</h2>
<p>CSRF, in its most basic form, is certainly the most easy to create attack vector paired with almost incalculable impact on the targeted application, it&#39;s users and storage mechanisms. Imagine the following case: A User is logged into GMail and checks his mails. After she stays logged in for a while - that&#39;s a regular behavior - the user opens a new Tab and navigates to another site. This site contains code that fires a regular HTTP Request to the GMail servers - an image tag is enough to do so. Since the user is still logged in, the request is processed with her privileges - maybe changes some settings or deletes some mails, thanks to the fact that HTTP is stateless - that&#39;s it. The attack has been performed successfully and neither the user nor GMail haven&#39;t even noticed.</p>
<p>So the longer the session needs to time out and the more the user surfs around untrusted sites, the higher the risk is to pop onto one with a CSRF attack on it. Any tag which fires a request to an external resource can be used to perform a hidden CSRF attack - including images, link tags, some meta tags, embed and object tags and so on. Same goes for attributes which load background images or similar. You can even check if you site has been validated by someone if you replace the <a href="http://en.wikipedia.org/wiki/Document_Type_Definition">DTD</a> file in the very header of the applications markup with a resource on your servers - <a href="http://sla.ckers.org/forum/read.php?4,3528,3528#msg-3528">that&#39;s CSRF too</a>.</p>
<p>So let&#39;s wrap it up - the following points are the basic things that characterize CSRF:</p>
<ul>
<li>As long as you are logged into Application A any other page can fire requests towards it with your privileges.</li>
<li>The longer the session lasts the higher is the risk.</li>
<li>It doesn&#39;t matter if the targeted functionality uses GET or POST - using POST just raises the bar a little bit.</li>
<li>XSS is CSRFs are very best fried - we&#39;re going to talk about that later in this post.</li>
<li>Social bookmarking is CSRFs&#39; second best friend - remember hat the attacker needs the user to visit his prepared site?</li>
<li>Complex forms or transactions with several steps are no protection against CSRF - just fire more than one request.</li>
</ul>
<h2 id="a-real-world-example">A real world example</h2>
<p>To make you understand the term CSRF even better here&#39;s a real world example. Keep in mind that we cannot uncover the platform&#39;s name and domain. Imagine a very big business platform where you can register and publish your contact details, your skills etc. You can search for colleagues and coworkers and communicate with them via the platform&#39;s messaging system. Since the owner of the platform wanted to gild the traffic, they&#39;ve created the ability to register a pro account with more possibilities for the user. The user can add and edit his account or credit card information via a HTML form. And as a matter of fact this exact form isn&#39;t protected against CSRF - so the following request would actually change your account info. Say goodbye to your pro account and hello to lots of annoying trouble.</p>
<pre><code>https://our.example.com/change_account
?paytype=debit
&amp;paytype_id=1234
&amp;paytype_field_1=123456789 // the account number
&amp;paytype_field_2=12345678 // the bank code
&amp;paytype_field_3=Richie+Rich // the account owner
&amp;paytype_field_4=BankOfHappiness // the bank&#39;s name
&amp;op=editpaytype.save
&amp;confirmmode=</code></pre><p>As mentioned earlier, it doesn&#39;t matter if this request is fired from an image tag or somewhere else - as long as you are logged in your account information will be changed. Same can be done when trying to invite new users to the platform via the invitation form:</p>
<pre><code>https://our.example.com/invite
?op=send
&amp;register_mode=0
&amp;first_name_1=test
&amp;last_name_1=test
&amp;email_1=someone@example.inv
&amp;subject=Buy%20those%pills!
&amp;salutation=1
&amp;body=Buy%20mortal!
&amp;send=submit
&amp;language=de</code></pre><pre><code class="language-html"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://our.example.com/change_account?paytype=debit&amp;paytype_id=1234&amp;paytype_field_1=123456789&amp;paytype_field_2=12345678&amp;paytype_field_3=Richie+Rich&amp;paytype_field_4=BankOfHappiness&amp;op=editpaytype.save&amp;confirmmode="</span>/&gt;</span>

<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"https://our.example.com/invite?op=send&amp;register_mode=0&amp;first_name_1=test&amp;last_name_1=test&amp;email_1=someone@example.inv&amp;subject=Buy%20those%pills!&amp;salutation=1&amp;body=Buy%20mortal!&amp;send=submit&amp;language=de"</span>/&gt;</span></code></pre>
<p>This way CSRF enables the attacker to spam arbitrary users from the account of the currently logged in user. Again annoying consequences for the user himself or the platform owners may follow. The examples show that it is very easy to perform a CSRF attack with very high impact. So now we come to the part of protection against CSRF.</p>
<h2 id="countermeasures-and-protection-against-csrf">Countermeasures and protection against CSRF</h2>
<p>There haven been many articles and discussions around this topic and this one aims at summing them up and finding an almost bullet-proof and easy to implement solution. Basically most times the following measures are mentioned to protect an application against CSRF attacks and decreasing the size of the attack surface.</p>
<ul>
<li>Using tokens for actions that store/update/delete/mail information</li>
<li>Using referrer checks when dealing with actions that store/update/delete/mail information</li>
<li>Using captchas or other mechanisms to make sure the request can&#39;t be brute-forced</li>
</ul>
<p><a href="http://www.businessinfo.co.uk/labs/csrf_defend/csrf_demos.php">This page</a> provides good examples for the above mentioned mechanisms. In case all of those three measurements were implemented properly the surface for CSRF attacks will become very small but the main problem is that any of them can be circumvented. For example the usage of unguessable tokens makes pretty sure the an attacker can&#39;t assume the correct URL without intense brute-forcing. A link with such a token could look like <a href="http://www.businessinfo.co.uk/labs/csrf_defend/url_tokens.php">this</a>. But all protective impact of this measurement is lost immediately when the application is vulnerable to XSS - because that way the token can be easily parsed off the page content and be used in the actual CSRF attack. The only thing an attacker has to do to get the token is to trick the user on the XSSed page and send the resulting response content to an arbitrary page of his. So one can see, XSS and CSRF are very good friends when coming to circumvention of defense mechanisms. Same problem exists for the referrer checks. Several older versions of the flash player were able to <a href="http://ha.ckers.org/blog/20060725/forging-http-request-headers-with-flash/">spoof the request headers</a> including of course the referrer. So a versatile attacker will have no problems circumventing that mechanism too. And captchas themselves <a href="http://www.captchakiller.com/">aren&#39;t bulletproof either</a> and additionally ship the problem that the application they&#39;re used on looses parts of its accessibility.</p>
<p>So the only thing a developer can do to make sure there are as few as possible CSRF vulnerabilities in his applications is the clever combination of the above mentioned mechanisms and to avoid XSS like hell. Most modern frameworks ship form tokens but a built in referrer check is pretty rarely to see. But it&#39;s easier to implement such a measurement in new and existing applications than it seems. First all requests which should be protected from CSRF have to be gathered into a list and the URL schemes have to be searched for patterns - most time something like the following:</p>
<ul>
<li><code>http://example.com/edit/...</code></li>
<li><code>http://example.com?action=store</code></li>
<li><code>http://example.com?id=123&amp;delete=1</code></li>
</ul>
<p>After having accomplished that. central instance is needed where any request has to go past before being processes by the application - mostly that&#39;s some file like index.php, index.asp or similar. If such a file isn&#39;t available most webservers feature a way to define such a file in their configuration. The most commonly used <a href="http://en.wikipedia.org/wiki/LAMP_%28software_bundle%29">LAMP</a> combo for example provides the <a href="http://php.net/ini.core">auto_prepend_file</a> option. After the critical requests were gathered successfully it&#39;s required to craft a regular expression, that matches those and is able to separate them from the rest of the requests the application understands. Now any incoming request that matches the pattern can be examined further by the prepended or index file. If a referrer appears that doesn&#39;t match the applications URL the request can be blocked and logged. Same goes for adding URL tokens to an already existing application - the prepended or index file can check for the existence and validity of the incoming token and that way the developer has way less work to do and validate the incoming traffic at a central position of his application. To make sure the generated markup positions the tokens in the critical forms the LAMP developer can use the <a href="http://php.net/manual/en/ini.core.php">auto_append_file</a> option and avoid customizing any template including those critical forms and links - same goes for the implementation of captchas if the loss of accessibility is acceptable for the platform&#39;s users. Of course, there&#39;s basic knowledge about regular expressions and some patience needed but the Internet is full of <a href="http://www.regular-expressions.info/">comprehensive tutorials</a>, guides and <a href="http://www.rexv.org/">tools</a>. So we see - defeating CSRF effectively is no black magic - even for existing applications and frameworks.</p>
<p>But also the user can protect themselves against soma variants of CSRF attacks - again with <a href="http://www.maone.net/">Giorgio Maone&#39;s</a> Firefox extension called <a href="http://noscript.net/">NoScript</a>. NoScript detects and oppresses cross-domain form submits. Needless to say that NoScript features a pretty advanced XSS protection too.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This article explained the basics of CSRF attacks and showed how they work and what impact they can have. Also, we&#39;ve learned how to read several techniques to mitigate and avert vulnerabilities for applications and the users themselves. Still, there are many other things to point out and hopefully the article will entail a discussion to cover all aspects which haven&#39;t found their way in. Also we&#39;d be happy to answers your questions - so feel free to contact us or comment on this post.</p>
<p><em>And by the way - the protection method we discussed above isn&#39;t even pure theory anymore. You can check out the <a href="http://php-ids.org/category/csrfx/">PHP5 library CSRFx</a> - which does the exact thing right here. Your opinion on this project is of course welcome too.</em></p>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ef14ae4ef69235fa6c3709438357819d?s=256&amp;d=retro" alt="Adrian Pastor"><span class="post-comment-author">Adrian Pastor</span><div class="post-comment-content">Asking for the password again when updating profile info (i.e.: password, name, address) is also a valid protection.

Need to check out CSRFx, I might start mentioning this library in my pentest report. btw, I think it could be pronounced easily: "sea surf X"

Very nice post on one of my favorite subjects.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ef14ae4ef69235fa6c3709438357819d?s=256&amp;d=retro" alt="Adrian Pastor"><span class="post-comment-author">Adrian Pastor</span><div class="post-comment-content">meant to say *reports*</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/e53f5d616931bfe8fa74bfd9f72e049e?s=256&amp;d=retro" alt="Mario Heiderich"><span class="post-comment-author">Mario Heiderich</span><div class="post-comment-content">Thx! I always have difficulties when telling my colleagues during scrum that I worked on the see-es-ar-eff-ex again ;)

Yes - there are several ways to protect against CSRF in very special situations. Such as the password change form as you mentioned. But this article is targeted to create more awareness about the topic itself and about easy to implement solutions. 

Keeping XSS out in combination with using tokens is pretty bullet-proof. The CSRFx even takes care of accidental multiple submits since it stores a cloud of tokens for each user depending on session ID and user agent. So there are not many situations left in which such a tool wouldn't work.

Nevertheless you are perfectly right. It not only the tool but the application and front end logic that can mitigate CSRF holes too. The password change form is  perfect example for that - as well as 'delete profile' forms and stuff like that.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ea8759d289d993ac120dc09abf5a2c94?s=256&amp;d=retro" alt="Josep"><span class="post-comment-author">Josep</span><div class="post-comment-content">Thanks for this article, I found it very clear and straightforward!

I've just started playing with it and found several webs vulnerable. Interesting... :)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/e8cbd3f22b3191ceea025207b179c2b3?s=256&amp;d=retro" alt="fatmatt"><span class="post-comment-author">fatmatt</span><div class="post-comment-content">Thanx!!
It showed very clearly CSRF, i'm already securing my web apps!! :)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/f1924a62813c03c0c5250e471622e5a6?s=256&amp;d=retro" alt="Tom"><span class="post-comment-author">Tom</span><div class="post-comment-content">Great article - I'm very happy it doesn't suggest adding the session ID to the URL as a defense for CRLF, as a gnucitizen article did back in March (Top google hit for CSRF defense). 

Great suggestions, and unlike the previous article it does not make the site more succeptible to some attacks in order to harden against CSRF.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">Tom, :) the older CSRF article was proposing a simple unobtrusive solution that actually works and it is very easy to implement.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/e53f5d616931bfe8fa74bfd9f72e049e?s=256&amp;d=retro" alt="Mario Heiderich"><span class="post-comment-author">Mario Heiderich</span><div class="post-comment-content">Thanks guys - the feedback is very appreciated. 

And on a sidenote: The CSRFx has been developed further the recent days and lots of bugs were fixed. Also we did some performance measurements and found out that despite of the thorough regex usage the project doesn't slow down your webapp significantly.

10x for the support!
Greetings,
.mario</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/9bec324a8011a2fa4e93e14e5840efcb?s=256&amp;d=retro" alt="Ardoooooon"><span class="post-comment-author">Ardoooooon</span><div class="post-comment-content">Thanks! I found this very enlighting indeed, and has now taken action to prevent CSRF.

- Despite that, I still find that some of the preventive measures proposed weakens my website against other forms of attacks</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/865b95e83e3d6c3bdb20441b6199ace7?s=256&amp;d=retro" alt="anshita"><span class="post-comment-author">anshita</span><div class="post-comment-content">If i need to write patterns for csrf in an xml file,which can be then scanned by any scanner to analyse a particular web service,what would those patterns be like.For example in sql injection,we use a pattern like "1=1" or "a=a".Please reply.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/eb018af922dc5f5c8db0e5fddbb584be?s=256&amp;d=retro" alt="suman"><span class="post-comment-author">suman</span><div class="post-comment-content">you are assuming that the page uses a GET request right ?? The example wont work with POST perhaps</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">both GET and POST can be used in CSRF attacks.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/266e1d56bfb834fd8b510f496edc8d38?s=256&amp;d=retro" alt="Matthew Nelson"><span class="post-comment-author">Matthew Nelson</span><div class="post-comment-content">"Referer" is not a bulletproof CSRF solution. The header can be stripped by privacy tools and corporate proxies. Browsers won't send the header for cross-domain HTTPS requests. Very old versions of Flash had a cross-domain header injection vulnerability. (See CVE-2006-5330.) Keep this in mind when choosing which requests to guard with "Referer" validation.</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2020 <a href=""></a>. All rights reserved.</p></footer></body></html>