<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Trapping HTTP Requests and Responses with Python</title><meta name="description" content="In my last post I showed my own implementation of n HTTPS Man-in-the-middle proxy written from scratch in Python. I've spent great deal of time to make the proxy as programmer-friendly as possible. In this post I am planning to show how you can use the code to write your own proxies in the spirit of Burp, Paros, WebScarab, RatProxy, etc."><meta property="name" content="Trapping HTTP Requests and Responses with Python"><meta itemprop="name" content="Trapping HTTP Requests and Responses with Python"><meta property="description" content="In my last post I showed my own implementation of n HTTPS Man-in-the-middle proxy written from scratch in Python. I've spent great deal of time to make the proxy as programmer-friendly as possible. In this post I am planning to show how you can use the code to write your own proxies in the spirit of Burp, Paros, WebScarab, RatProxy, etc."><meta itemprop="description" content="In my last post I showed my own implementation of n HTTPS Man-in-the-middle proxy written from scratch in Python. I've spent great deal of time to make the proxy as programmer-friendly as possible. In this post I am planning to show how you can use the code to write your own proxies in the spirit of Burp, Paros, WebScarab, RatProxy, etc."><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Ftrapping-http-requests-and-responses-with-python%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Ftrapping-http-requests-and-responses-with-python%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/trapping-http-requests-and-responses-with-python/"><meta property="og:title" content="Trapping HTTP Requests and Responses with Python"><meta property="og:description" content="In my last post I showed my own implementation of n HTTPS Man-in-the-middle proxy written from scratch in Python. I've spent great deal of time to make the proxy as programmer-friendly as possible. In this post I am planning to show how you can use the code to write your own proxies in the spirit of Burp, Paros, WebScarab, RatProxy, etc."><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Ftrapping-http-requests-and-responses-with-python%2F?w=1024"><meta name="twitter:title" content="Trapping HTTP Requests and Responses with Python"><meta name="twitter:description" content="In my last post I showed my own implementation of n HTTPS Man-in-the-middle proxy written from scratch in Python. I've spent great deal of time to make the proxy as programmer-friendly as possible. In this post I am planning to show how you can use the code to write your own proxies in the spirit of Burp, Paros, WebScarab, RatProxy, etc."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Ftrapping-http-requests-and-responses-with-python%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/blog/">Blog</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">Trapping HTTP Requests and Responses with Python</h1><div class="date">Wed, 18 Feb 2009 11:52:34 GMT</div><div class="author">by pdp</div><div id="post-content"><p>In my <a href="/blog/python-ssl-mitm-proxy-and-more/">last post</a> I showed my own implementation of n HTTPS Man-in-the-middle proxy written from scratch in Python. I&#39;ve spent great deal of time to make the proxy as programmer-friendly as possible. In this post I am planning to show how you can use the code to write your own proxies in the spirit of Burp, Paros, WebScarab, RatProxy, etc.</p>
<p>Why is this interesting? Well, it is interesting to Python developers/hackers only. The fact is that there are a few HTTPS-enabled proxies with tamperable capabilities for Python. However, none of them are actually easy to use or even reliable enough for my likings. Not to mention that none of them were designed to be extended upon. While it is true that my code hasn&#39;t bee fully tested, and there were some tiny issues already reported (to be fixed soon), I find the code a lot easier to work with as you will see later in this post.</p>
<p>So, let&#39;s make a proxy. First, you need to get the <code>httpservers.py</code> file from <a href="/blog/python-ssl-mitm-proxy-and-more/">here</a>. Make sure that you get the latest version from the SVN. Let&#39;s start with a simple example:</p>
<pre><code class="language-python"><span class="keyword">import</span> httpservers
<span class="keyword">import</span> SocketServer

<span class="class"><span class="keyword">class</span> <span class="title">Handler</span><span class="params">(httpservers.SimpleObservableProxyHTTPRequestHandler)</span>:</span>
    <span class="function"><span class="keyword">def</span> <span class="title">observe_request</span><span class="params">(self, data)</span>:</span>
        <span class="keyword">print</span> <span class="string">'&gt;&gt;'</span>, repr(data)[:<span class="number">100</span>] <span class="comment"># observe browser requests</span>
        <span class="keyword">return</span> data

    <span class="function"><span class="keyword">def</span> <span class="title">observe_response</span><span class="params">(self, data)</span>:</span>
        <span class="keyword">print</span> <span class="string">'&lt;&lt;'</span>, repr(data)[:<span class="number">100</span>] <span class="comment"># observer server responses</span>
        <span class="keyword">return</span> data

<span class="class"><span class="keyword">class</span> <span class="title">Server</span><span class="params">(SocketServer.ThreadingMixIn, httpservers.SimpleObservableProxyHTTPServer)</span>:</span>
    <span class="keyword">pass</span>

<span class="keyword">print</span> <span class="string">'Starting server on localhost:8080...'</span>
srv = Server((<span class="string">'localhost'</span>, <span class="number">8080</span>), Handler, <span class="string">'/path/to/cert/file'</span>)
srv.serve_forever()</code></pre>
<p>In order to make this work you need to generate a self-signed certificate like this:</p>
<pre><code>openssl req -x509 -nodes -days 365 -newkey rsa:1024 -keyout mycert.pem -out mycert.pem</code></pre><p>...and replace <code>&#39;/path/to/cert/file&#39;</code> with the path to the certificate.</p>
<p>If you execute the above snippet, you should be able to get the proxy running on port 8080. Every request that you send will be outputted on the screen with the prefix <code>&gt;&gt;</code>, while every server response will be prefixed with <code>&lt;&lt;</code>. Keep in mind that I am not displaying the complete request/response (<code>repr(data)[:100]</code>, only the first 100 characters) because I don&#39;t want to clog my screen with too much data.</p>
<p>So far, so good. Notice that <code>observe_request</code> and <code>observe_response</code> methods return the received data like that: <code>return data</code>. This is very important! These methods not only can sniff the data but they can modify it on the fly. For example, we can inject additional JavaScript for each server response by doing something similar to this:</p>
<pre><code class="language-python"><span class="function"><span class="keyword">def</span> <span class="title">observe_response</span><span class="params">(self, data)</span>:</span>
    <span class="keyword">return</span> data + <span class="string">'&lt;script&gt;/* javascript here */&lt;/script&gt;'</span></code></pre>
<p>The example above is not complete because we don&#39;t want to append the string to each response but only to those that have mime type of <code>text/html</code>. Nevertheless you get the picture.</p>
<p>The good thing about <code>observe_request</code> and <code>observe_response</code> methods is that they both operate on raw data, i.e. they use the actual data that is sent through the server and client sockets. There is no intermediate layer in between. This is very powerful as we can guarantee that our modifications are not modified by code which tries to be RFC compliant for example. In that respect we can completely screw up the requests and responses. This is important if we want to write some kind of a fuzzer or even a tool that deal with data at socket level. This feature actually lacks from most proxies and this is the reason why I tried to implement it in mine.</p>
<p>Because we deal with raw data, we need to parse it in order to get the useful bits and pieces out of it (of course only if we need to). This is quite simple. Future versions of my code will contain a helper method to do this but for now you can use something like this:</p>
<pre><code class="language-python"><span class="keyword">import</span> StringIO
...
...
    fp = StringIO.StringIO(data)

    request_line = fp.readline()
    headers = self.MessageClass(fp)
    data = fp.read()
    ...
    <span class="keyword">print</span> self.headers[<span class="string">'host'</span>] <span class="comment"># will print the host</span></code></pre>
<p>...and we print the <code>Host</code> header. I told you that this is going to be easy.</p>
<p>This is pretty much it. There is no point of explaining further because the implementation is self-explanatory.</p>
<p>Due to high-load of projects and other internal developments we are looking to expand our team with 1-2 new editors. If you feel that you can contribute to this blog and our community, do not hesitate to get in touch with us.</p>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/b6a28fa0da793609f14027a39751a7a8?s=256&amp;d=retro" alt="Jay"><span class="post-comment-author">Jay</span><div class="post-comment-content">Looks nice. You may want to consider the numerous WSGI objects / middleware for parsing request / response. 

It's good that you can also get the data raw, but rather then writing "yet another helper function" I could see how being able to insert these standard components into your MITM stream would make it even more powerful.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">Hi Jay,

You don't want to mess with WSGI for just parsing simple requests and responses. <code>MessageClass</code> is actually <code>mimetools.Message</code> which is enough to parse headers and leave the rest to you as pure data. Also, I like that the functions work in raw as often we just want to perform simple regex operations without reconstructing the data.

Thanks for the suggestions.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c510febb9bed68b5cc4a09f076701e0f?s=256&amp;d=retro" alt="Anon"><span class="post-comment-author">Anon</span><div class="post-comment-content">Out of curiosity, why not use Twisted for this? It seems like you reimplemented a lot of functionality.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c510febb9bed68b5cc4a09f076701e0f?s=256&amp;d=retro" alt="Anon"><span class="post-comment-author">Anon</span><div class="post-comment-content">Whoops, let me elaborate on my previous point - someone mentioned unit testing as a potential concern for this library. Twisted, although it does have its flaws, has constructs that allow you to simulate packet and connections and such with relative ease. Otherwise you're going to have to hack together something on your own for fully exercising the functionality of the library. 

This is a good working script, but what's probably going to happen is that you're slowly going to tack more and more features onto until it becomes a nightmare to deal with until you decide to reimplement half of some existing networking lib from scratch in V2.

http://twistedmatrix.com/trac/wiki/TwistedTrial

Anyway, good work as has been said, i'll be keeping tabs on this.

-Signed,
Jaded Software Engineer</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">while it is true that twisted can provide a lot more solid base for this proxy server, the truth is that proxies are not that complicated. they are relatively simple actually.

right now my code relies on pyOpenSSL but once the python team introduce SSL server support, it will be easy to switch and as such make the module run without any dependencies, which is my ultimate goal.</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2022 <a href=""></a>. All rights reserved.</p></footer></body></html>