<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Traversing the Web</title><meta name="description" content="Every modern browser implements a security sandbox also known as the Same Origin Policy. This sandbox restricts dynamic resources to access others that are from a different context (origin). As such, JavaScript code that is located at `http://www.gnucitizen.org` can access only resources that match the same protocol (`http`), the same domain (`gnucitizen.org`) and the same port (`80`). On the other hand `ftp://ftp.gnucitizen.org`, `https://www.gnucitizen.org` and `http://www.gnucitizen.org:81` are not accessible."><meta property="name" content="Traversing the Web"><meta itemprop="name" content="Traversing the Web"><meta property="description" content="Every modern browser implements a security sandbox also known as the Same Origin Policy. This sandbox restricts dynamic resources to access others that are from a different context (origin). As such, JavaScript code that is located at `http://www.gnucitizen.org` can access only resources that match the same protocol (`http`), the same domain (`gnucitizen.org`) and the same port (`80`). On the other hand `ftp://ftp.gnucitizen.org`, `https://www.gnucitizen.org` and `http://www.gnucitizen.org:81` are not accessible."><meta itemprop="description" content="Every modern browser implements a security sandbox also known as the Same Origin Policy. This sandbox restricts dynamic resources to access others that are from a different context (origin). As such, JavaScript code that is located at `http://www.gnucitizen.org` can access only resources that match the same protocol (`http`), the same domain (`gnucitizen.org`) and the same port (`80`). On the other hand `ftp://ftp.gnucitizen.org`, `https://www.gnucitizen.org` and `http://www.gnucitizen.org:81` are not accessible."><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Ftraversing-the-web%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Ftraversing-the-web%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/traversing-the-web/"><meta property="og:title" content="Traversing the Web"><meta property="og:description" content="Every modern browser implements a security sandbox also known as the Same Origin Policy. This sandbox restricts dynamic resources to access others that are from a different context (origin). As such, JavaScript code that is located at `http://www.gnucitizen.org` can access only resources that match the same protocol (`http`), the same domain (`gnucitizen.org`) and the same port (`80`). On the other hand `ftp://ftp.gnucitizen.org`, `https://www.gnucitizen.org` and `http://www.gnucitizen.org:81` are not accessible."><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Ftraversing-the-web%2F?w=1024"><meta name="twitter:title" content="Traversing the Web"><meta name="twitter:description" content="Every modern browser implements a security sandbox also known as the Same Origin Policy. This sandbox restricts dynamic resources to access others that are from a different context (origin). As such, JavaScript code that is located at `http://www.gnucitizen.org` can access only resources that match the same protocol (`http`), the same domain (`gnucitizen.org`) and the same port (`80`). On the other hand `ftp://ftp.gnucitizen.org`, `https://www.gnucitizen.org` and `http://www.gnucitizen.org:81` are not accessible."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Ftraversing-the-web%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">Traversing the Web</h1><div class="date">Tue, 10 Oct 2006 06:48:09 GMT</div><div class="author">by pdp</div><div id="post-content"><p>Every modern browser implements a security sandbox also known as the Same Origin Policy. This sandbox restricts dynamic resources to access others that are from a different context (origin). As such, JavaScript code that is located at <code>http://www.gnucitizen.org</code> can access only resources that match the same protocol (<code>http</code>), the same domain (<code>gnucitizen.org</code>) and the same port (<code>80</code>). On the other hand <code>ftp://ftp.gnucitizen.org</code>, <code>https://www.gnucitizen.org</code> and <code>http://www.gnucitizen.org:81</code> are not accessible.</p>
<p>Although quite clever, the same origin policy can be bypassed in a number of ways. AJAX developers are already familiar with most of them. The range of techniques includes dynamic SCRIPT elements, dynamic IFRAME elements and request proxies.</p>
<p>In this article I am going to take the concept of request proxies further by showing how attackers can use them to write JavaScript code that can bypass the same origin restriction (<strong>in a way</strong>).</p>
<p>Request proxies are nothing but simple applications that take the request from the browser and transmit it to another location. The reason for this maneuver is obvious. For example, if the current application is located at <code>http://www.example.com</code> and it requires data from <code>http://api.datastore.com</code> the call needs to be initiated from the server since the client lacks particular set of functionalities. It is not that JavaScript cannot make HTTP requests (<code>XMLHttpRequest</code> object) to <code>http://api.datastore.com</code>, it is that the security settings of the browser do not to allow it unless the same origin check is successfully passed.</p>
<p>The workaround in that case is quite simple. Instead of directly accessing <code>http://api.datastore.com</code>, the current application can use an instance of <code>XMLHttpRequest</code> object to access <code>http://www.example.com/proxy.php</code> which will make the request to <code>http://api.datastore.com</code> on behalf of <code>http://www.example.com</code>. You see, PHP is not restricted and scripts are in the same origin.</p>
<blockquote>
<p>This is a problematic solution if you think about it. AJAX gained popularity mainly because it is lighter than the traditional GET/RENDER cycle still used by many web applications today. Request proxies take the entire load and eat server resources. As such, they are not very AJAX like. That is the reason why many developers switch to JSON with dynamic SCRIPT elements.</p>
</blockquote>
<p>How does this affect the security? Surely attackers may need to perform cross-requests in certain situations; exploiting XSS or SQL Injection vulnerability on a different domain, or spidering for targets. They can easily set a proxy request handler with a few lines in PHP and start exploiting. However, as soon as their malicious activities are spotted, their account will be terminated. That is definitely not a long term solution. Moreover, in case a JavaScript worm is about to be realized, relying on private request proxies is just not efficient since the malicious location can be blocked by IP and domain restrictions.</p>
<p>The solution is to use public proxies, especially the ones that are very important; Google Translate for example. Blocking Google Translate or Google is not nice. Imagine how many users will be unhappy when they are not able to access their GMail because a worm is spreading. Google will object as well. Vendors need to find other patterns in the worm structure to write a generic blocking filter. You get the point.</p>
<p>Public proxies are harder to use. The reason for this is because they have never been designed for AJAX development. They are bulky, sometimes slow and the attacker needs to find a way of abusing their functionalities still complying with the Same Origin Restrictions. The second part of this article discusses the solution I came up with when playing with <a href="http://translate.google.com">Google Translate</a> and <a href="http://www.proxydrop.com/">Proxydrop</a>.</p>
<p>Abusing public proxies is a matter of designing a communication protocol, putting some nested IFRAMEs and a timer. In the example below I make heavy use of fragment identifies (#) as well.</p>
<p>In the first stage, the attacker creates a hidden IFRAME that points to the public proxy URL which is set to proxy <code>document.location</code> with added fragment identifier. For example, if the current location is <code>http://www.example.com/infected.html</code>, the following IFRAME will be created:</p>
<pre><code class="language-html"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">'http://proxy.com?url=http%3A%2F%2Fwww.example.com%2Finfected.html%23stage1'</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></code></pre>
<p>where <code>http%3A%2F%2Fwww.example.com%2Finfected.html%23stage1</code> URL encoded is <code>http://www.example.com/infected.html#stage1</code> in plain text</p>
<p>The fragment identifier <code>#stage1</code> denotes that when the current location is loaded from the proxy, <code>#stage1</code> will take place instead of the normal document flow. This is achieved by performing a check in the document body similar to the following:</p>
<pre><code class="language-javascript"><span class="keyword">if</span> (<span class="built_in">document</span>.location.hash == <span class="string">'#stage1'</span>) {
    ...
    do stage1
    ...
} <span class="keyword">else</span> {
    ...
    do <span class="keyword">default</span>
    ...
}</code></pre>
<p>In simple words <code>#stage1</code> will execute under <code>http://proxy.com</code> domain. This stage is designed to unify or bypass the domain restrictions. At <code>#stage1</code> another IFRAME is created that points to the location which the attacker is interested in. In case the attacker is interested in spidering Google the following IFRAME will be created:</p>
<pre><code class="language-html"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://proxy.com?url=http%3A%2F%2Fwww.google.com%2Fsearch%3Fq%3Dquery"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></code></pre>
<p>where <code>http%3A%2F%2Fwww.google.com%2Fsearch%3Fq%3Dquery</code> URL encoded is h<code>ttp://www.google.com/search?q=query</code> plain text</p>
<p>This IFRAME is also loaded in the <code>http://proxy.com</code> domain. This means that <code>#stage1</code> has access to this IFRAME document (the same origin check is bypassed) and can read all the information that is inside.</p>
<p>The next step is to collect the desired information and Base64 encode it. The attacker can encode the entire document if they like. The hardest part is to transmit that Base64 encoded value back to the location where the attack was launched from.</p>
<p>Child IFRAMEs have no access to parent documents. Still, there is a workaround that can be used. What the <code>#stage1</code> document needs to do is to set the fragment identifier of the parent page with the desired data. Child IFRAMES cannot access <code>parent.location</code> but they can easily alter the hash member variable of the location object.  This can be achieved in the following way:</p>
<pre><code class="language-javascript">parent.location.hash = <span class="string">'#data:'</span> + base64encoded_content;</code></pre>
<p>Upon execution the parent document location will expand with a new fragment identifier. It must be noted that this will not cause a refresh. Now the collected data is in the current page fragment identifier and it can be read by accessing:</p>
<pre><code class="language-javascript"><span class="built_in">document</span>.location.hash</code></pre>
<p>There is no way to hook a function on <code>document.location.hash</code> change so a timer needs to be set that will check for <code>#data</code> fragment identifier every defined period of time. As soon as a change in the fragment identifier is spotted the data will be read, decoded and used.</p>
<p>This is how attackers can abuse public proxies and write viruses and worms on their backbone. The larger and more important the proxy is the higher the chances for success are.</p>
<p>The example provided above is not generic. In fact it is a bit bulky and can be definitely improved. The reason why I used this technique is because there is a proof of concept tool that makes use of it. The tool is called JavaScript SPIDER and it can be found <a href="/blog/javascript-spider">here</a>.</p>
<p>Abusing public proxies is only one of the many techniques that can be implemented in the personal toolbox of every client-side hacker. This subject can be definitely expanded with more examples and techniques but I will leave that for some other time.</p>
<p><em>If you have any ideas of how to improve this technique or how to prevent it from happening, don&#39;t hesitate to leave a comment.</em></p>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/bc99640b554acac6fb6b03be8ff047b1?s=256&amp;d=retro" alt="Acidus"><span class="post-comment-author">Acidus</span><div class="post-comment-content">There are some really cool attacks you can do with Ajax Bridges/proxies/gateways. Most of the time it makes more sense for an attacker to use the bridge on www.example.com to attack api.datastore.com than to directly attack api.datastore.com

Check out slides 37 - 45 (ignore the slanting)

<a href="http://www.spidynamics.com/spilabs/education/presentations/BillyHoffman-Ajax(in)security.pdf" rel="nofollow">http://www.spidynamics.com/spilabs/education/presentations/BillyHoffman-Ajax(in)security.pdf</a></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/803e289068dc08d5b34ae47778e67bb6?s=256&amp;d=retro" alt="maluc"><span class="post-comment-author">maluc</span><div class="post-comment-content">Wow, the author of stripe snoop..? That code helped me more than you could know, so.. thanks ^^

-maluc</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/8e71e197b04669e0f5712f520528d7a7?s=256&amp;d=retro" alt="Gar"><span class="post-comment-author">Gar</span><div class="post-comment-content">I'm probably very naive, but I just wish that browser implementors got rid of cookies in iframes. The only sensible use would be doubleclick and urchin anyway.</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2021 <a href=""></a>. All rights reserved.</p></footer></body></html>