<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Client-side SQL Injection Attacks</title><meta name="description" content="A couple of days ago, Google unleashed a new product called Google Gears. At the beginning I was sceptical about the purpose and the actual benefit of this project but I soon realised that indeed it is very powerful and it does save developers from a lot of trouble when dealing with AJAXy applications. The two most useful/interesting Google Gears (GGears) features are the relational persistent storage and the worker pool. Both of these features are quite interesting. Let's see why?"><meta property="name" content="Client-side SQL Injection Attacks"><meta itemprop="name" content="Client-side SQL Injection Attacks"><meta property="description" content="A couple of days ago, Google unleashed a new product called Google Gears. At the beginning I was sceptical about the purpose and the actual benefit of this project but I soon realised that indeed it is very powerful and it does save developers from a lot of trouble when dealing with AJAXy applications. The two most useful/interesting Google Gears (GGears) features are the relational persistent storage and the worker pool. Both of these features are quite interesting. Let's see why?"><meta itemprop="description" content="A couple of days ago, Google unleashed a new product called Google Gears. At the beginning I was sceptical about the purpose and the actual benefit of this project but I soon realised that indeed it is very powerful and it does save developers from a lot of trouble when dealing with AJAXy applications. The two most useful/interesting Google Gears (GGears) features are the relational persistent storage and the worker pool. Both of these features are quite interesting. Let's see why?"><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fclient-side-sql-injection-attacks%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fclient-side-sql-injection-attacks%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/client-side-sql-injection-attacks/"><meta property="og:title" content="Client-side SQL Injection Attacks"><meta property="og:description" content="A couple of days ago, Google unleashed a new product called Google Gears. At the beginning I was sceptical about the purpose and the actual benefit of this project but I soon realised that indeed it is very powerful and it does save developers from a lot of trouble when dealing with AJAXy applications. The two most useful/interesting Google Gears (GGears) features are the relational persistent storage and the worker pool. Both of these features are quite interesting. Let's see why?"><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fclient-side-sql-injection-attacks%2F?w=1024"><meta name="twitter:title" content="Client-side SQL Injection Attacks"><meta name="twitter:description" content="A couple of days ago, Google unleashed a new product called Google Gears. At the beginning I was sceptical about the purpose and the actual benefit of this project but I soon realised that indeed it is very powerful and it does save developers from a lot of trouble when dealing with AJAXy applications. The two most useful/interesting Google Gears (GGears) features are the relational persistent storage and the worker pool. Both of these features are quite interesting. Let's see why?"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fclient-side-sql-injection-attacks%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">Client-side SQL Injection Attacks</h1><div class="date">Tue, 05 Jun 2007 21:33:36 GMT</div><div class="author">by
<a href="/members/pdp.html">pdp</a></div><div id="post-content"><p>A couple of days ago, Google unleashed a new product called <a href="http://code.google.com/apis/gears/">Google Gears</a>. At the beginning I was sceptical about the purpose and the actual benefit of this project but I soon realised that indeed it is very powerful and it does save developers from a lot of trouble when dealing with AJAXy applications. The two most useful/interesting Google Gears (GGears) features are the <a href="http://code.google.com/apis/gears/api_database.html">relational persistent storage</a> and the <a href="http://code.google.com/apis/gears/api_workerpool.html">worker pool</a>. Both of these features are quite interesting. Let&#39;s see why?</p>
<p>The relational persistent storage allows developers to mange databases and tables on the client the same way we do it on the server. The backend is SQLite which quite obviously supports SQL queries. Here is the problem: if user provided data is passed as part of any of the queries without being sanitized then we have a SQL Injection. This is not everything though. There are two ways attackers can take advantage of the Gears&#39; persistent storage. The first one is through a XSS attack on the domain that makes use of Gears&#39; persistent storage. This one is very nasty since attackers are able to control the queries that are sent to the backend. They can dump, modify and completely destroy any database or table.</p>
<p>The second problem is a variation of the first one but it is a bit more twisted. Attackers can make use of a client-side SQL Injection hole to inject and echo back a peace of HTML/JavaScript code that loads more malicious code inside the user browser, effectively causing XSS. Depending how the attacked application is written, attackers might be able to persistently infect the client with a virus that will reoccur every time the attacked application is loaded. All in all, there is nothing new in here, although SQL Injection, an attack vector that used to be considered a server-side problem only, has become a client-side problem too.</p>
<p>The worker pool is also quite interesting and can be used for malicious purposes too. This is how Google describes the worker pool:</p>
<blockquote>
<p>In web browsers a single time-intensive operation, such as I/O or heavy computation, can make the UI unresponsive. The WorkerPool module runs operations in the background, without blocking the UI. Scripts executing in the WorkerPool will not trigger the browser&#39;s <strong>unresponsive script</strong> dialog.</p>
</blockquote>
<p>This means that attackers can put memory/resource intensive processes in the background without affecting your browser. I wonder what these process will do... hmmm... like scanning your Intranet maybe or maybe even performing crypto calculations. Who knows? All I know is that making something clever in JavaScript without making the browser hang is hard. Well, not any more. Browsers will get better and that will increase the surface of client-side attacks.</p>
<p>Google Gears is actually very useful. However, I am thinking to disable it for now. The project is still in beta, so I hope that by the time it reaches a first release some of the security problems will be resolved, although I cannot really see how that will happen since we are not talking about bugs in Gears, but fundamental insecurities that can occur by using features in unintended way by taking advantage of insecure codding practices.</p>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ac7005eff7720218df4cf0c72ddf6a3d?s=256&amp;d=retro" alt="Simon Willison"><span class="post-comment-author">Simon Willison</span><div class="post-comment-content">The Google Gears database API uses bind parameters which are immune to SQL injection. Developers could still write bad code, but Gears makes it easy enough to avoid SQL injection that only very poor developers are likely to end up with injection holes.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">Simon, you are right... the point is that it is still possible. Only the time will show. One thing that Googe Gears definitely promotes is persitent XSS. Even if your SQL queries are right but you trust the user input, you may end up saving JavaScript inside your database and then recalling it everytime the user does an action to retrieve that malicious entry. I know that the Firefox team is also working on a persistent storage for Firefox3 which is also based on SQLite. IE and Opera will follow. That will only increase the attack surface of attacks such as SQL Injection, XSS and CSRF.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/97fd8407dc3175b4aeebbf4e71b4d620?s=256&amp;d=retro" alt="Aaron Boodman (Gears developer)"><span class="post-comment-author">Aaron Boodman (Gears developer)</span><div class="post-comment-content">You're right that Gears does open up more possibilities once a website has an XSS hole. Developers will have to treat the client database as suspect and validate it on the server, much the same way they validate other data coming from the client.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/8f8ff21a67437febebc70afd19364e95?s=256&amp;d=retro" alt="name"><span class="post-comment-author">name</span><div class="post-comment-content"><blockquote>Even if your SQL queries are right but you trust the user input,</blockquote>

why would anyone trust user input? (When attempting to avoid the obvious, of course)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/7905d373cfab2e0fda04b9e7acc8c879?s=256&amp;d=retro" alt="anonymous"><span class="post-comment-author">anonymous</span><div class="post-comment-content">isnt there protection against that kind of attack?</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2022 <a href=""></a>. All rights reserved.</p></footer></body></html>