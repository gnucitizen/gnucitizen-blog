<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>The Generic XSS Worm</title><meta name="description" content="When we think of computer worms, we generally think about operating-system based worms such as the famous Code Red, which replicated itself 250,000 times in approximately nine hours on July 19, 2001. Its replication was made possible by a vulnerability within MS Windows platform. Firewalls and defense in depth help mitigate the spread of worms by providing layers of protection between public and private networks; however, a new age worm is upon us, the XSS Worm aka the Web 2.0 worm."><meta property="name" content="The Generic XSS Worm"><meta itemprop="name" content="The Generic XSS Worm"><meta property="description" content="When we think of computer worms, we generally think about operating-system based worms such as the famous Code Red, which replicated itself 250,000 times in approximately nine hours on July 19, 2001. Its replication was made possible by a vulnerability within MS Windows platform. Firewalls and defense in depth help mitigate the spread of worms by providing layers of protection between public and private networks; however, a new age worm is upon us, the XSS Worm aka the Web 2.0 worm."><meta itemprop="description" content="When we think of computer worms, we generally think about operating-system based worms such as the famous Code Red, which replicated itself 250,000 times in approximately nine hours on July 19, 2001. Its replication was made possible by a vulnerability within MS Windows platform. Firewalls and defense in depth help mitigate the spread of worms by providing layers of protection between public and private networks; however, a new age worm is upon us, the XSS Worm aka the Web 2.0 worm."><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fthe-generic-xss-worm%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fthe-generic-xss-worm%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/the-generic-xss-worm/"><meta property="og:title" content="The Generic XSS Worm"><meta property="og:description" content="When we think of computer worms, we generally think about operating-system based worms such as the famous Code Red, which replicated itself 250,000 times in approximately nine hours on July 19, 2001. Its replication was made possible by a vulnerability within MS Windows platform. Firewalls and defense in depth help mitigate the spread of worms by providing layers of protection between public and private networks; however, a new age worm is upon us, the XSS Worm aka the Web 2.0 worm."><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fthe-generic-xss-worm%2F?w=1024"><meta name="twitter:title" content="The Generic XSS Worm"><meta name="twitter:description" content="When we think of computer worms, we generally think about operating-system based worms such as the famous Code Red, which replicated itself 250,000 times in approximately nine hours on July 19, 2001. Its replication was made possible by a vulnerability within MS Windows platform. Firewalls and defense in depth help mitigate the spread of worms by providing layers of protection between public and private networks; however, a new age worm is upon us, the XSS Worm aka the Web 2.0 worm."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fthe-generic-xss-worm%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">The Generic XSS Worm</h1><div class="date">Wed, 20 Jun 2007 22:52:15 GMT</div><div class="author">by
david-kierznowski</div><div id="post-content"><p>When we think of computer worms, we generally think about operating-system based worms such as the famous Code Red, which replicated itself 250,000 times in approximately nine hours on July 19, 2001. Its replication was made possible by a vulnerability within MS Windows platform. Firewalls and defense in depth help mitigate the spread of worms by providing layers of protection between public and private networks; however, a new age worm is upon us, the XSS Worm aka the Web 2.0 worm.</p>
<p>The Samy XSS Worm - the first of its kind to make headlines carried a payload that would display the string &quot;but most of all, Samy is my hero&quot; on a victim&#39;s profile. When a user viewed that profile, the worm would infect the visitor&#39;s profile via a Cross-Site Scripting payload. Within just 20 hours, of its October 4, 2005 release, over one million user profiles were infected, making Samy one of the fastest spreading viruses of all time. In this post, I am going to summarize several publicly discussed JavaScript Malware techniques and depict how future worms may look like, based on what we have today.</p>
<p>XSS is a powerful engine on which to build a platform independent virus and whether we are ready or not, attackers are definitely going to be utilising these techniques in the future and the ground work and education factors must be put into place now. Think about this, an XSS engine has the potential to propagate much faster than an operating-system based worm, requires less effort in many cases (not all), requires little or no authentication and is client-side which means the XSS engine can propagate across network boundaries utilising the user&#39;s circle of trust. This is almost the antithesis of traditional worms, which are server-side meaning it struggles to propagate over network boundaries and they usually require high operating-system level access.</p>
<p>XSS engines will require these fundamentals:</p>
<ul>
<li>ability to identify targets (the XSS vulnerability)</li>
<li>an XSS payload (the purpose or exploit); and* continuity (the propagation technique)</li>
</ul>
<p>This article will introduce Scrape, Specific and Generic XSS engines.</p>
<h2 id="scrape">Scrape</h2>
<p>Scrape XSS Worms utilise external resources to identify targets (i.e. Google, xssed.com) - pdp recently released an article titled, <a href="/blog/the-next-super-worm">The Next Super Worm</a> which basically uses <a href="http://xssed.com">xssed.com</a> to identify vulnerable targets.  Note that this example &quot;scrapes&quot; the targets from a third party resource.</p>
<h2 id="specific">Specific</h2>
<p>Specific XSS Worms usually have an individual target - the Samy XSS worm is a perfect example here. It exploited a specific vulnerability in a specific target. Its focus is not to spread across network(s) but rather to remain in once place infecting a particular aspect of a website or service.</p>
<h2 id="generic">Generic</h2>
<p>Generic XSS Worms which make assumptions - an example here would be a worm which exploits environment variables in application frameworks like PHP&#39;s <code>$_SERVER[&#39;PHP_SELF&#39;]</code>. This method is ideal for blind XSS worms, where you do not know what the web server is running ( i.e. my <a href="http://michaeldaw.org/news/news-100607/">wp-scanner</a> tool uses generic XSS tests to find vulnerabilities in WordPress themes; it doesn&#39;t care what theme the user is running). Another really good example is Solarius&#39;s recently found XSS <a href="http://www.securityfocus.com/bid/23832">vulnerability</a> in ASP.NET&#39;s <code>PATH_INFO</code> variable which affects the latest version of SharePoint and possibly many other ASP.NET applications. The Generic XSS engine category could also extend to include web server or application flaws (i.e. XST, Universal PDF XSS etc).</p>
<blockquote>
<p>I hope I have given you some fruit for thought, and to encourage the Internet community to move forward in coming up with new techniques, methods and strategies to combat the rise of client-side flaws. Web 2.0 security will require us to lengthen our strides if we are to come up with effective solutions; a number of excellent contributions and ideas have already begun and we encourage these individuals and organizations to continue on.</p>
</blockquote>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/e9e7690eccc0e9b2ab8ec6a375c96bbd?s=256&amp;d=retro" alt="ntp"><span class="post-comment-author">ntp</span><div class="post-comment-content">Browser developers should build anti-XSS, LocalRodeo, content-restrictions, and SafeHistory/SafeCache concepts into the browser. Someone (preferably browser developers, but could be administrators) should separate browser profiles (different process id's) into at least two separate browsers / browser profiles:

1) Firefox for the Internet - will not connect to RFC1918
2) Firefox for your Intranet - will only connect to RFC1918

Jeremiah Grossman suggested a way to make this more transparent, but I suggest this stricter method.

Vulnerability hunters should disclose responsibly to security, cert, noc, hostmaster, postmaster, and webmaster email addresses at top-level domains, preferably to someone who has a GPG public key available in a key server (or use something similar like Hushmail or IBE).  They should also check for any incident response policies and vulnerability reporting processes the organization or website owner may already have in place.  There is no reason to go to another source or through an intermediary.  If all email bounces or there is no response in two weeks, vulnerability hunters should try calling a person by acquiring a phone number of an appropriately titled employee on jigsaw.com, spoke.com, or linkedin.com or from whois as a last resort.  If you can find an XSS, you should know how to social engineer or footprint an email address and phone number.

Administrators should respond to and fix problems within 2 weeks (XSS moves faster than buffer overflows) or full-disclosure is fully appropriate.  Like I've said before - if administrators can respond to an SSL certificate expiring within 2 weeks - then they can also respond to an XSS finding in the same amount of time.  The vulnerability researcher can then co-ordinate a fix/disclosure schedule with the vendor and should provide remediation support if necessary.  If you can find an XSS with a scanning tool, you should learn how to fix them for others.

IT administrators for users should setup the ability to whitelist URL's (e.g. http://whitetrash.sf.net ) if they think their environment can support it.  They should also ensure OS, browser, and browser plugin automatic updates.  Administrators should scan and patch, just like regular vulnerability management.  Good administrators will enforce use of a safe browser similar to the one described in my first paragraph.

Most importantly, developers should respond to issue tracking about XSS findings (reported by the administrators / operators) immediately as the highest priority... higher than application availability issues (24x7x365).  They should always use validators that are built into their framework properly.  Before coding anything, they should have an enforceable coding standard built into their IDE.  They should use source and static-file code checkers in their IDE.  They should use source checkers (again), static-file checkers (again), and path/code coverage tools (e.g. concolic unit testing) that run fuzz testing across all inputs at build time, including on dependencies.  They should combine model checkers and continuous integration tools (especially build schedulers), ensuring a clean release.

Applications should be monitored for security events using application monitoring tools (not network security tools or log management tools) by both operators/administrators and developers.

Web Application Security Scanners and Web Application Firewalls are OPTIONAL but NOT REQUIRED.

I refer to this strategy as NTPolicy.  You may use or change it however you like.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">ntp, that was great comment.

IMHO, things are a bit more complicated. You say:

<blockquote>Before coding anything, they should have an enforceable coding standard built into their IDE. They should use source and static-file code checkers in their IDE. They should use source checkers (again), static-file checkers (again), and path/code coverage tools (e.g. concolic unit testing) that run fuzz testing across all inputs at build time, including on dependencies. They should combine model checkers and continuous integration tools (especially build schedulers), ensuring a clean release.</blockquote> 

Of course, this is the way forward. However, scripted languages are very hard to automatically examine them, mainly because they are nothing like compiled languages. Most of the IDEs that I've seen which have these types of facilities work only for .NET or Java and nothing else is supported. Although it may seams that most corporate applications use something like that, the truth is that there are a plethora of things that cannot be easily ignored.

But yes, you are right. We should do it.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/1d95d2324345e3dd2e41d6066cc1b492?s=256&amp;d=retro" alt="david.kierznowski"><span class="post-comment-author">david.kierznowski</span><div class="post-comment-content">I don't think there is a clean cut solution right now, we are in for the long-haul.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/e9e7690eccc0e9b2ab8ec6a375c96bbd?s=256&amp;d=retro" alt="ntp"><span class="post-comment-author">ntp</span><div class="post-comment-content"><blockquote>Of course, this is the way forward. However, scripted languages are very hard to automatically examine them, mainly because they are nothing like compiled languages. Most of the IDEs that Iâ€™ve seen which have these types of facilities work only for .NET or Java and nothing else is supported. Although it may seams that most corporate applications use something like that, the truth is that there are a plethora of things that cannot be easily ignored.</blockquote>

Scripting languages have one great aspect: they are focused on Test-Driven Development (TDD) to "get all the bugs out".  This is fast, works extremely well, and "drives" development to the end goal.

Unfortunately, tested code is not the end goal.  Also - even more extremely unfortunately - DFT (Design for Test) gets skipped.  How could Agile developers skip the most important part?  Well, I guess they don't call them script kiddies for nothing!  Also see: http://www.jwz.org/doc/cadt.html

Although I would argue that "testing is fun", especially when you find security-related bugs or flaws.

Microsoft uses the SDL, which is largely a waterfall model.  The end goal of the SDL is security.  Microsoft actually has a better model, where the end goal is everything everybody really wants.  It's called Design for Operations (DFO) http://www.codeplex.com/dfo/

Unfortunately, tools like VSMMD for DFO only leak out from Microsoft once every two to ten years, and usually in crippled form.  Their internal tools such as PreSharp (source checker for C#), FxCop (static file checker for CLR), Magellan (code coverage), and FuzzGuru (path/code coverage with fuzz testing) - as well as their internal coding standards (esp/espx) are not well-known.  Sure, they do have some public tools (that still require VS 2k5/2k8) for coding standards, SAL  annotations, and model checking (AppVerif).  But let's take a look at what Java offers all as open-source.

Java, with Eclipse plugins, supports CheckStyle, FormatOnSave, and many other options for enforcing a particular coding standard.  Source checkers (PMD, Jlint, Hammurapi), and static-file checkers (FindBugs, SofCheck) are available both in the IDE and in the build tools (e.g. Ant, Maven2, etc).  Model checkers such as Java PathFinder, have some amazing capabilities - and even the Java-specialized tools for CI and build automation (e.g. Luntbuild) are quite complete for this type of work.

Scripters can do the same (Groovy especially), but Ruby, Python, and probably even PHP can have a more planned/focused development model and use the right tools.  It's not just Java and .NET.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/e9e7690eccc0e9b2ab8ec6a375c96bbd?s=256&amp;d=retro" alt="ntp"><span class="post-comment-author">ntp</span><div class="post-comment-content">Oh I forgot to add Java code coverage tools such as EMMA (and EclEmma for Eclipse) and the combined path/code coverage tool with fuzz testing (jCUTE).

Note that Ruby has rcov for code coverage and supports many build options with rake.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/a49d504d79a751345bf67be81688d007?s=256&amp;d=retro" alt="David"><span class="post-comment-author">David</span><div class="post-comment-content">Guys, great thanks for sharing this info. Could anybody tell me does XSIO - Cross Site Site Image Overlaying still working in social resources like myspace, digg etc? I tried to find this vuln, but i couldn't.. :(</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">David, they are aware of the technique so I guess it will be harder.</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2022 <a href=""></a>. All rights reserved.</p></footer></body></html>