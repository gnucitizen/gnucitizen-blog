<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>General Purpose Fuzzer.py</title><meta name="description" content="Fuzzing is a quite important for security researchers mainly because it helps going through the boring stuff quickly. Generally speaking, fuzzers are tools for automation. Unfortunately most moderns fuzzers are a lot more then automation tools. They are big, bloated and most of all, highly unusable, imho. And if you want to do some fuzzing, first of all you have to learn how they were built, and this is not a trivial thing."><meta property="name" content="General Purpose Fuzzer.py"><meta itemprop="name" content="General Purpose Fuzzer.py"><meta property="description" content="Fuzzing is a quite important for security researchers mainly because it helps going through the boring stuff quickly. Generally speaking, fuzzers are tools for automation. Unfortunately most moderns fuzzers are a lot more then automation tools. They are big, bloated and most of all, highly unusable, imho. And if you want to do some fuzzing, first of all you have to learn how they were built, and this is not a trivial thing."><meta itemprop="description" content="Fuzzing is a quite important for security researchers mainly because it helps going through the boring stuff quickly. Generally speaking, fuzzers are tools for automation. Unfortunately most moderns fuzzers are a lot more then automation tools. They are big, bloated and most of all, highly unusable, imho. And if you want to do some fuzzing, first of all you have to learn how they were built, and this is not a trivial thing."><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fgeneral-purpose-fuzzer_py%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fgeneral-purpose-fuzzer_py%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/general-purpose-fuzzer_py/"><meta property="og:title" content="General Purpose Fuzzer.py"><meta property="og:description" content="Fuzzing is a quite important for security researchers mainly because it helps going through the boring stuff quickly. Generally speaking, fuzzers are tools for automation. Unfortunately most moderns fuzzers are a lot more then automation tools. They are big, bloated and most of all, highly unusable, imho. And if you want to do some fuzzing, first of all you have to learn how they were built, and this is not a trivial thing."><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fgeneral-purpose-fuzzer_py%2F?w=1024"><meta name="twitter:title" content="General Purpose Fuzzer.py"><meta name="twitter:description" content="Fuzzing is a quite important for security researchers mainly because it helps going through the boring stuff quickly. Generally speaking, fuzzers are tools for automation. Unfortunately most moderns fuzzers are a lot more then automation tools. They are big, bloated and most of all, highly unusable, imho. And if you want to do some fuzzing, first of all you have to learn how they were built, and this is not a trivial thing."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fgeneral-purpose-fuzzer_py%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/blog/">Blog</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">General Purpose Fuzzer.py</h1><div class="date">Mon, 17 Dec 2007 00:15:42 GMT</div><div class="author">by pdp</div><div id="post-content"><p>Fuzzing is a quite important for security researchers mainly because it helps going through the boring stuff quickly. Generally speaking, fuzzers are tools for automation. Unfortunately most moderns fuzzers are a lot more then automation tools. They are big, bloated and most of all, highly unusable, imho. And if you want to do some fuzzing, first of all you have to learn how they were built, and this is not a trivial thing.</p>
<p>Due to my frustration with modern fuzzers and the simple fact that I need them in my day-to-day work, I decided to write my own in Python, because Python rocks. The fuzzer, which I developed this afternoon, is contained within a single python module. This makes it very portable and easy to use. On the other hand, the fuzzing subroutines do not use anything fancy but the standard python functionalities (generators and closures), which improves the learning curve quite drastically. Last but not least it is really fun to use it from the command line. If you don&#39;t trust me, just give it a try. The following is the actual source code of the tool:</p>
<pre><code>[/files/2007/12/fuzzer.py](/files/2007/12/fuzzer.py)

When prototyping the fuzzer I realized that I need a very good way to separate generated data from logic. Therefore, I came up with the concepts of generators (the stuff I&#39;ve used in my [previous work](/blog/web-client-fuzzer_py) on fuzzers) and actuators. Generators simply **yield** data while actuators consume it and do something useful with it. The following is an example of a dummy generator and actuator, also available within the fuzzer source code. Keep in mind that you can input external modules within the fuzzer by using the `-i` or `--import` command line options and as such modularize your work a bit more:

#
# GENERATORS
#
def generator_dummy(globals):
    &quot;&quot;&quot; the dummy generator outputs all numbers between 0 and 99 &quot;&quot;&quot;

    def run():
        for i in range(0, 100):
            yield i

    return run

#
# ACTUATORS
#
def actuator_dummy(globals):
    &quot;&quot;&quot; the dummy actuator returns all supplied values &quot;&quot;&quot;

    def run(value):
        return value

    return run</code></pre><p>As you can see, very simple stuff really. The simpler the better, I say! Unfortunately, the tool is only self documented (check the usage). There is no other external documentation how to use it. If you are willing to help with putting some basic tutorials together, you are more then welcome. Please, let me know. Of course, credits will be given where are due.</p>
<p><em>So, there you go. General Purpose fuzzing can be actually a simple task.</em></p>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/54dc38bc9fc58b7b010a4b780fafedbe?s=256&amp;d=retro" alt="nnp"><span class="post-comment-author">nnp</span><div class="post-comment-content">No offence mate but your fuzzer is about 3 years behind the times and not particularly original. There is a reason modern fuzzers have all that extra fluff. Also, a quick google would have saved you the hassle of writing this I think. There are plenty of scripts out there that do the same thing. From what I can see the reason your script is so short is that it basically does nothing. It's a watered down version of peach (which also has the idea of generators etc) without all the useful 'bloat'. 

Now I'm not saying fuzzers need to be huge behemoths of applications. Obviously experience has shown that often a simple script with a clear aim can find bugs quickly but if you want things like crash detection, logging, monitoring etc then all that bloat is necessary. Fuzzing can have a steep learning curve for a reason, to do it properly is a skill. Sure at the moment any idiot can still fuzz a couple of bugs in some obscure application but to do it properly isn't a 5 minute quick hack.

What you have there is pretty much what most hackers had themselves a couple of years ago. I'm not saying it's not useful, just that it's not as much of an original idea as you might think. 

The only reason I bothered to reply is that I'm kind of surprised as most of the stuff found here is usually pretty cool and off the beaten track ;)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">nnp, no one claims to be original, however, what I do claim is that by using something like this, you have a lot better chances to get your head around various problems without becoming a slave of them and wasting your time too much. and this to me matters <strong>a lot</strong>.

many tools out there just try to be too clever, including <strong>peach</strong>, tools should not be clever. I think that we are clever enough to figure it out on our own. What tools should do is to automate the boring stuff. In my case, repetition is quite boring. so you should really take this tool from that prospective.

on your last note, well, I love simplicity. I believe that simple is better and more affective. If I can find a problem, like fuzzing technology, which is extremely bloated and I can simplify it to the extend where it does the same but in a minimalistic way, then I considered it as an accomplishment. it is as simple as that. :)

so, although you might not use this fuzzer, I believe that there are tones of people who will use it and will find it very interesting and better suited for the job then <strong>peach</strong>. They might even use some of the concepts to construct their own fuzzers. There is nothing better then custom tools!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/54dc38bc9fc58b7b010a4b780fafedbe?s=256&amp;d=retro" alt="nnp"><span class="post-comment-author">nnp</span><div class="post-comment-content">My point though is that this extra cleverness is what seperates an excellent fuzzer from an average one. Sure your script in its current incarnation could be hacked on to find some bugs but to really exercise a protocol/application you're going to have to put in a lot of work. So while you might be saving yourself effort in the short term, in the long term you would have been better off spending 15 minutes getting to grips with a fuzzing framework like Sulley and working from there. 

And 15 mins is the most it would take. After that you just map out your protocol in block form and you magically have a much more powerful fuzzer because of all that 'bloat'. Of course if its you're first time fuzzing anything you might wonder about 'block based fuzzing' or whatever but there's the same learning curve with what you have, just less of a pay off at the end.

I agree that Peach is over complex. It was after using Peach for the first time that I wrote something quite similar to your script, but I wouldn't be so quick to write off all fuzzing frameworks because of it. There are plenty out there that are easy to understand for beginners yet offer the power a more advanced user might need (Sulley is a perfect example)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ef14ae4ef69235fa6c3709438357819d?s=256&amp;d=retro" alt="Adrian Pastor"><span class="post-comment-author">Adrian Pastor</span><div class="post-comment-content">I think writing your own fuzzer is one of those things that every hacker/security enthusiast should do at some point.

I do agree with nnp that frameworks sometimes offer fuzzing features that are required. However, after having talked to some guys who have found impressive number of security holes I've learned  most holes were found with very simple fuzzing scripts or through source code audits.

Not to be biased, but like pdp, I'm in love with simple tools that do something specific.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/54dc38bc9fc58b7b010a4b780fafedbe?s=256&amp;d=retro" alt="nnp"><span class="post-comment-author">nnp</span><div class="post-comment-content">Of course making something as simple as possible is desirable but it is possible to whip up a very straight forward fuzzer using Sulley (excuse my overuse of this particular framework as an example but its quite good) which has a massive library of fuzz strings. If that doesn't find any holes you can then easily expand it using Sulley's primitives and modifiers. Using a framework with this kind of support allows you to start out small and simple and work upwards. On the other hand if you start with something small and simple and unfortunately you don't find anything... where to then? Modify your framework? Start from scratch?

Sulley also comes with other tools that are very useful such as process monitoring tools which allow you to start/monitor/restart a program as well as logging a memory dump of the process that crashed and the fuzz file that caused it to crash. On top of that it can also chain single fuzz tests to fuzz deep into a protocol. These extras can safely be ignored if you manage to knock over the process initially but if you need their support you have it.

I guess in the end your choice of tool comes down to how much resistance the target program puts up weighed against how much you want to kill it via a fuzzer as opposed to getting into a code audit/RE session.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/f2d7c9f3033aeeee10edf2c46a75aa03?s=256&amp;d=retro" alt="Strongarm"><span class="post-comment-author">Strongarm</span><div class="post-comment-content">pdp! sure Python rocks but Ruby takes drugs and has lots of sex with plenty of women. I'd hope you would have written it in Javascript, js being your baby in all.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">hihi</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2021 <a href=""></a>. All rights reserved.</p></footer></body></html>