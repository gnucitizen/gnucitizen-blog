<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>JavaScript Remoting Dangers</title><meta name="description" content="&gt; This month our guest blogger is Billy Hoffman, the lead researcher at SPI Dynamics and author of StripeSnoop, an application which analyzes data on magnetic stripes. Billy has been a frequent speaker at industry events including Interz0ne, Toorcon, Black Hat Federal, PhreakNIC, FooCamp, O'Reilly Media Emerging Technology Conference and ShmooCon. In this post Billy is taking us on a quite interesting trip into the dangerous world of JavaScript remoting."><meta property="name" content="JavaScript Remoting Dangers"><meta itemprop="name" content="JavaScript Remoting Dangers"><meta property="description" content="&gt; This month our guest blogger is Billy Hoffman, the lead researcher at SPI Dynamics and author of StripeSnoop, an application which analyzes data on magnetic stripes. Billy has been a frequent speaker at industry events including Interz0ne, Toorcon, Black Hat Federal, PhreakNIC, FooCamp, O'Reilly Media Emerging Technology Conference and ShmooCon. In this post Billy is taking us on a quite interesting trip into the dangerous world of JavaScript remoting."><meta itemprop="description" content="&gt; This month our guest blogger is Billy Hoffman, the lead researcher at SPI Dynamics and author of StripeSnoop, an application which analyzes data on magnetic stripes. Billy has been a frequent speaker at industry events including Interz0ne, Toorcon, Black Hat Federal, PhreakNIC, FooCamp, O'Reilly Media Emerging Technology Conference and ShmooCon. In this post Billy is taking us on a quite interesting trip into the dangerous world of JavaScript remoting."><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fjavascript-remoting-dangers%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fjavascript-remoting-dangers%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/javascript-remoting-dangers/"><meta property="og:title" content="JavaScript Remoting Dangers"><meta property="og:description" content="&gt; This month our guest blogger is Billy Hoffman, the lead researcher at SPI Dynamics and author of StripeSnoop, an application which analyzes data on magnetic stripes. Billy has been a frequent speaker at industry events including Interz0ne, Toorcon, Black Hat Federal, PhreakNIC, FooCamp, O'Reilly Media Emerging Technology Conference and ShmooCon. In this post Billy is taking us on a quite interesting trip into the dangerous world of JavaScript remoting."><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fjavascript-remoting-dangers%2F?w=1024"><meta name="twitter:title" content="JavaScript Remoting Dangers"><meta name="twitter:description" content="&gt; This month our guest blogger is Billy Hoffman, the lead researcher at SPI Dynamics and author of StripeSnoop, an application which analyzes data on magnetic stripes. Billy has been a frequent speaker at industry events including Interz0ne, Toorcon, Black Hat Federal, PhreakNIC, FooCamp, O'Reilly Media Emerging Technology Conference and ShmooCon. In this post Billy is taking us on a quite interesting trip into the dangerous world of JavaScript remoting."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fjavascript-remoting-dangers%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">JavaScript Remoting Dangers</h1><div class="date">Tue, 30 Jan 2007 21:31:08 GMT</div><div class="author">by
<a href="/members/pdp.html">pdp</a></div><div id="post-content"><blockquote>
<p>This month our guest blogger is <a href="http://www.memestreams.net/users/Acidus">Billy Hoffman</a>, the lead researcher at <a href="http://www.spidynamics.com/">SPI Dynamics</a> and author of <a href="http://stripesnoop.sourceforge.net/">StripeSnoop</a>, an application which analyzes data on magnetic stripes. Billy has been a frequent speaker at industry events including Interz0ne, Toorcon, Black Hat Federal, PhreakNIC, FooCamp, O&#39;Reilly Media Emerging Technology Conference and ShmooCon. In this post Billy is taking us on a quite interesting trip into the dangerous world of JavaScript remoting.</p>
</blockquote>
<p>I&#39;d like to thank pdp for giving me the opportunity to write a blog post. I&#39;d like to use this post to discuss the various methods JavaScript can use to make HTTP requests. Each method has its own pros and cons that lend themselves to be used in different situations. We will ignore using JavaScript coupled with extra technologies such as Java applets or Flash and focus entirely on native JavaScript objects (or objects provided through ActiveX) and the DOM environment. I&#39;m sure there are others and I hope this post can serve as a starting point for a larger project to collect information and techniques about how JavaScript is used to perform various malware tasks like propagating worms and instigating data theft.</p>
<p>One method JavaScript can use to send HTTP requests is creating HTML tags using the <code>document.createElement</code> function. There are all sorts of HTML tags/attributes pairs that will issue an HTTP request when rendered by the browser. There are the obvious ones like IMG+src, but also obscure ones like TABLE+background or INPUT+src. All of these tags issue a so-called &quot;blind&quot; request, meaning that JavaScript is not capable of seeing the response. This method can also be used only to issue GET requests. This makes the method is a good way to send information in the query string one way to a 3rd party such as a 3rd party site to collect stolen cookies. However, blind GETs are limited in the amount of data they can send to a 3rd party through the query string by the allowed length of a URL. While there are no explicit limits defined in any RFC, anything more than 2K to 4K is pushing it. This method can also be used as an XSRF attack vector. JavaScript could be used with a timer to create multiple blind GET requests that are necessary to walk through a multiple stage process such as a money transfer.</p>
<p>JavaScript can also use the <code>document.createElement</code> method to dynamically create FORM and INPUT tags and use them to send POSTs to arbitrary domains. If the domain the JavaScript is POSTing to is the same as the domain it came from, JavaScript will be able to access the response. This is a handy method to use when you need JavaScript to send a very large amount of data to a 3rd party that would exceed the amount of data you can safely put in the query string of a URL.</p>
<p>In addition to using HTML tags, JavaScript has a native object which can issue HTTP requests. The Image object is supplied by the DOM environment and allows JavaScript to dynamically request images from any web server. As soon as you set the src property on the image object, a blind GET is issued to the URL you assigned. This tends to be a better method to send blind GETs than creating HTML tags because you avoid the overhead of instantiating DOM elements. Also, when using an Image object the response is not entirely blind. Events can be set to trap when the image has finished loading and what the size of the image is. This creates a side channel for JavaScript to communicate with certain 3rd party hosts using the dimensions of the image. In practice, XBM images tend to work best because you can specify arbitrary lengths and widths up to a 15bit integer without actually needing an image of that size. You can also use the time domain as a side channel by varying when an image loads. Both these methods have several limitations and it is better to use an alternate method such as remote scripting to exchange certain information between 3rd party sites that the JavaScript author controls.</p>
<p>Finally, there are IFRAME remoting and XmlHttpRequest. These methods are interesting because they allow JavaScript to access the response (if sent to the domain the JavaScript came from). Specifically, they allow JavaScript to proactively fetch pages asynchronously and in a hidden fashion. Because the browser will automatically add the appropriate cookies and HTTP authentication info to the requests (as is does for all requests), these methods are very useful for malware authors to actively steal specific data from a user that is stored on a website.</p>
<p>So which method to use? Many people believe XmlHttpRequest doesn&#39;t help XSS malware authors. They argue attacker have already been able to proactively fetch content using IFRAME remoting.</p>
<p>There are several problems with IFRAME remoting which XmlHttpRequest solves. First of all, IFRAMEs were never designed to be used in the fashion, making this a fairly clunky procedure. Remember that an attacker doesn&#39;t have control of the content that&#39;s been returned by the IFRAME. This means that the response that populates the IFRAME is not going to contain JavaScript which will execute a callback function in the attacker&#39;s payload which is inside of the parent document for the IFRAME. The response that is in the IFRAME is simply whatever information the attacker is trying to steal. To extract any data from the IFRAME an attacker would create the IFRAME and then hook the onload event, as shown in the following code:</p>
<pre><code class="language-html">var iframe = document.createElement(&#39;IFRAME&#39;);
//have the IFRAME download the content we want to steal
iframe.src = &#39;http://site.com/AddressBook.php);
//make the IFRAME invisible
iframe.style=&quot;width:0px; height:0px; border: 0px&quot;
//set our function to call when the IFRAME is done loading
iframe.onload = callbackFunction;
//now add the IFRAME to the DOM.
Document.body.appendChild(iframe);</code></pre>
<p>In the above code, the attacker is dynamically creating an IFRAME whose SRC attribute points to AddressBook.php. AddressBook.php is a web page which contains all the email addresses in a user&#39;s address book. The attacker also styles the IFRAME sothat it takes up no visible space and does not have a border surrounding it. This styling renders the IFRAME invisible to the user.</p>
<p>So how does the attacker access the data they wish to steal? As we noted before the markup of AddressBook.php is not going to contain code that would notify the attacker or pass the contents of AddressBook.php to the attacker. This only makes sense as AddressBook.php is not accessed in this way when the application is functioning normally. Instead, the attacker has to register a JavaScript function to execute once the IFRAME has finished loading the content specified in its SRC attribute. Here lies the problem. The attacker is only interested in stealing the email addresses. These email addresses will appear as text inside of the HTML that is returned by AddressBook.php. The HTML will also link to images, external style sheets, JavaScript files, Flash objects and other resources that are so common place on today&#39;s Internet. Unfortunately for the attacker, the IFRAME does not call the function specified in its onload attribute until after all the external resources referenced by the document in the IFRAME have been downloaded and instantiated.</p>
<p>How bad is this for the attacker? Consider CNN&#39;s website <a href="http://www.cnn.com/">http://www.cnn.com/</a>. Using the View Dependencies extension for Firefox, we see that to display CNN fully, an astonishing 363 kilobytes (KB) of data must be downloaded to a user&#39;s machine. Only 23 KB of this, about 6% of the total data, is the HTML representing the text on the web page. Since the attacker is trying to extract text they care about downloading the HTML. However, because of the way IFRAMEs and the onload event work, the entire page must be downloaded before the attacker can extract data. Let&#39;s put this in prospective. Downloading 363KB of data over a 1 Mbps connection takes approximately 3 seconds. Downloading 23KB over the same link takes 0.17 seconds, or is 15 times faster. While 3 seconds may not seem like a whole lot of time you should focus on the 15 times figure. In this scenario, an attacker could request and siphon data from 15 pages using the XmlHttpRequest method for every 1 page retrieved using IFRAME.</p>
<p>In the interest of fairness, it should be noted that the entire 363 KB of CNN are not downloaded each and every time. CNN implements caching to ensure that the certain files do not need to be requested again. However, the browser does still send conditional GET requests. That is, the browser sends a complete GET request which includes an HTTP header telling CNN to return only the resource if it is newer than the version the browser has cached locally. Even if the browser&#39;s resource is still valid, the server must respond with an HTTP 304 message. This tells the browser to use its local copy. Even if all the local copies of the resources are fresh, some amount of network traffic still has to occur. From the attacker&#39;s point of view all of this traffic is a waste because they cannot use it and don&#39;t care about it. The bottom line is using IFRAME remoting to extract content from a web page is always slower than using an XmlHttpRequest. Thus, while IFRAME remoting can be used to siphon confidential data from a user without their knowledge, XmlHttpRequest makes this a much more realistic attack vector. Add on the fact the XmlHttpRequest allows access to response headersa and (some) modification of the request headers and XmlHttpRequest is the clear winner over IFRAME remoting for an attackers toolkit when used for data theft. This may be why nearly all the XSS malware to date uses XmlHttpRequest instead of IFRAME remoting to propagate.</p>
<p>Remember that JavaScript has many different ways to send HTTP requests. If you are in a situation where some are not allowed or filtered, chances are there is another method you can use. Even if all methods are explicated filtered, JavaScript is so dynamic you can probably get around it. For <a href="https://chatbotkit.com/examples">example</a>, if the function <code>document.createElement</code> cannot be used, assemble your function call character by character in a string and then <code>eval</code> it. If <code>eval</code> is not allowed, use a <code>setTimeout</code>, which can also eval strings. JavaScript is far more powerful and people are always underestimating it. Much like Perl, there are many way to do the same thing.</p>
<p><em>Thanks again to pdp for providing this chance, and happy hacking.</em></p>
<p>To help you out, here is a table summarizing the pros and cons for the different methods JavaScript can use to send HTTP requests.</p>
<table>
<thead>
<tr>
<th>Method</th><th>HTTP methods</th><th>Can access response</th><th>Can see response headers</th><th>Can communicate with any domain</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dynamically created HTML Tags</td><td>GET</td><td>No</td><td>No</td><td>Yes</td>
</tr>
<tr>
<td>Dynamically built FORM tag</td><td>GET, POST</td><td>Only if FORM posts to same domain as JavaScript code</td><td>No</td><td>Yes</td>
</tr>
<tr>
<td>Image Object</td><td>GET</td><td>Yes, but only image dimensions</td><td>No</td><td>Yes</td>
</tr>
<tr>
<td>Remote Scripting</td><td>GET</td><td>Yes, if response is JavaScript</td><td>No</td><td>Yes</td>
</tr>
<tr>
<td>iFrame Remoting</td><td>GET</td><td>Only if iframe src is in same domain as JavaScript code</td><td>No</td><td>Yes</td>
</tr>
<tr>
<td>XmlHttpRequest Object</td><td>Any</td><td>Yes</td><td>Yes</td><td>No</td>
</tr>
</tbody>
</table>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ef14ae4ef69235fa6c3709438357819d?s=256&amp;d=retro" alt="pagvac"><span class="post-comment-author">pagvac</span><div class="post-comment-content">Nice job Acidus! This is a very nice summary of different ways to craft nasty HTTP requests using JavaScript.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/c4db4e65c9f09f2a373fcaefa5e2bfb4?s=256&amp;d=retro" alt="pdp"><span class="post-comment-author">pdp</span><div class="post-comment-content">very interesting summary. good stuff.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/f23b9ef5bd79326e8f77393579a94cea?s=256&amp;d=retro" alt="busin3ss"><span class="post-comment-author">busin3ss</span><div class="post-comment-content">awesome article... you guys rock! Keep up the good work</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/d4518e6223a1a82f53dc4919d0165151?s=256&amp;d=retro" alt="James"><span class="post-comment-author">James</span><div class="post-comment-content">Hello, 

Can you please clarify how this example works:

<pre><code>var iframe = document.createElement('IFRAME');
//have the IFRAME download the content we want to steal
iframe.src = 'http://site.com/AddressBook.php);
//make the IFRAME invisible
iframe.style="width:0px; height:0px; border: 0px"
//set our function to call when the IFRAME is done loading
iframe.onload = callbackFunction;
//now add the IFRAME to the DOM.
Document.body.appendChild(iframe);</code></pre>

From what I can tell, the above code will only work if this script is included on the site.com domain.  iframes prevent access to their data by parent windows of different domain names.  Therefore, I don't see how an attacker can access this data?  

I use this technique in one of my applications to pass data from one website to another, but I have control of both websites.  I placed a script tag on domainA from domainB.  without access to domainA, I don't see how this can be accomplished.

I hope my question is clear.  Please email me if it's not as I feel it's important that I understand the security implications of this technique for my product.

Thanks,
James</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/1e4e7e58ea7ac7d01e32829962732fda?s=256&amp;d=retro" alt="Vladimir"><span class="post-comment-author">Vladimir</span><div class="post-comment-content">One small addition - IMG vector can also get the image size in IE8 and IE9 through the attribute fileSize. More here: http://seclists.org/fulldisclosure/2010/Apr/288</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2025 <a href=""></a>. All rights reserved.</p></footer></body></html>