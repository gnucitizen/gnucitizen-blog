<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Username Enumeration Vulnerabilities</title><meta name="description" content="We all know what username enumeration vulnerabilities are about. In this post, I will talk about them within the context of web application pentesting and will discuss some of the common issues I've come across during my experience while working at ProCheckUp."><meta property="name" content="Username Enumeration Vulnerabilities"><meta itemprop="name" content="Username Enumeration Vulnerabilities"><meta property="description" content="We all know what username enumeration vulnerabilities are about. In this post, I will talk about them within the context of web application pentesting and will discuss some of the common issues I've come across during my experience while working at ProCheckUp."><meta itemprop="description" content="We all know what username enumeration vulnerabilities are about. In this post, I will talk about them within the context of web application pentesting and will discuss some of the common issues I've come across during my experience while working at ProCheckUp."><meta property="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fusername-enumeration-vulnerabilities%2F?w=1024"><meta itemprop="image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fusername-enumeration-vulnerabilities%2F?w=1024"><meta property="og:type" content="website"><meta property="og:url" content="https://www.gnucitizen.org/blog/username-enumeration-vulnerabilities/"><meta property="og:title" content="Username Enumeration Vulnerabilities"><meta property="og:description" content="We all know what username enumeration vulnerabilities are about. In this post, I will talk about them within the context of web application pentesting and will discuss some of the common issues I've come across during my experience while working at ProCheckUp."><meta property="og:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fusername-enumeration-vulnerabilities%2F?w=1024"><meta name="twitter:title" content="Username Enumeration Vulnerabilities"><meta name="twitter:description" content="We all know what username enumeration vulnerabilities are about. In this post, I will talk about them within the context of web application pentesting and will discuss some of the common issues I've come across during my experience while working at ProCheckUp."><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="http://s.wordpress.com/mshots/v1/https%3A%2F%2Fwww.gnucitizen.org%2Fblog%2Fusername-enumeration-vulnerabilities%2F?w=1024"><link type="text/css" href="/blog.css" rel="stylesheet"><script type="text/javascript" src="/blog.js"></script></head><body><header id="header"></header><nav id="topnav"><ul><li><a href="/">Home</a></li><li><a href="/projects.html">Projects</a></li><li><a href="/files">Files</a></li><li><a href="/about.html">About</a></li></ul></nav><article><div id="content"><h1 class="title">Username Enumeration Vulnerabilities</h1><div class="date">Wed, 04 Apr 2007 09:34:18 GMT</div><div class="author">by
pagvac</div><div id="post-content"><p>We all know what username enumeration vulnerabilities are about. In this post, I will talk about them within the context of web application pentesting and will discuss some of the common issues I&#39;ve come across during my experience while working at <a href="http://www.procheckup.com/">ProCheckUp</a>.</p>
<p>So basically we have an application that will reveal to us when a username already exists on the system. If you do a bit of <a href="http://www.google.com/search?q=username+enumeration+vulnerability&amp;num=100">research</a> on this type of vulnerability, you usually find the <a href="https://chatbotkit.com/examples">example</a> of a login page which, when submitting wrong credentials, will specifically inform the user (and attackers) whether the entered username is already present on the system or not. This is what I like to call a username enumeration vulnerability of <em>bruteforcable</em> type, because we usually run a dictionary attack to exploit the responses of the application. There is another type of username enumeration vulnerability which I would like to call <em>dumpable</em>. In dumpable username enumeration vulnerabilities, the target application coughs up a list of existing usernames. You might wonder how this could happen. I&#39;ve seen it work by accessing exposed config files (i.e. <code>users.conf.xml</code>). Another example that comes to my mind is portal applications which sometimes allow you to do advanced searches and obtain lists of usernames existing on the system without requiring you to be logged in. In this post, we will focus on <em>bruteforcable</em> username enumeration vulns.</p>
<p>Although nothing stops you from blindly trying common set of credentials such as <code>admin/admin</code>, <code>admin/password</code>, <code>test/test</code> and so on, enumerating usernames does definitely increase the chance of an account being cracked. Think of username enumeration as the first stage in the process of cracking a set of credentials. The problem is that not all web applications are vulnerable to this type of flaw. However, there are ways we can push the limits.</p>
<p>Let&#39;s say that you access <code>https://acme-site.com/logon.aspx</code>, and you try to authenticate with the credentials <code>madeupusername/password</code>. The application, if vulnerable, will respond with a message similar to the following one:</p>
<blockquote>
<p>Authentication failure: entered username does not exist.</p>
</blockquote>
<p>However, if we enter an existing username, the application will then give a different message such as:</p>
<blockquote>
<p>Authentication failure: incorrect password entered.</p>
</blockquote>
<p>Username enumeration vulnerabilities can be found in several other ways besides probing changes of responses in login authentication errors. I&#39;ve seen four different ways to find bruteforcable username enumeration issues:</p>
<ul>
<li>analyzing changes in error messages on login facilities (as discussed above)</li>
<li>analyzing changes in error messages on password recovery facilities</li>
<li>analyzing changes in error messages on account signup facilities</li>
<li>probing existing URIs</li>
</ul>
<p>Each of these types have pros and cons. If I could choose out of all of them I would definitely pick the last two (I&#39;ll explain why later).</p>
<p>Login facilities (login pages) are the most popular way to find username enumeration on web apps. However, for this very reason , its popularity, security-aware developers might have already considered the issues related to having a login error reveal existing usernames. In other words, you&#39;re less likely to enumerate usernames through a login page. Please note that I&#39;m <em>not</em> saying it&#39;s rare to find username enumeration vulns on login pages, but rather that they are simply less likely to be found than other types.</p>
<p>The second problem with enumerating usernames through a login failure is that you are at risk of locking out accounts if a lockout account policy is enabled. Although only one authentication error should not lock out an account, you&#39;re playing with fire. Say that you&#39;re writing a script to enumerate usernames using a dictionary attack. While tweaking the script you may probe some usernames more than once, therefore taking the risk of locking out the target accounts.</p>
<p>For the second method, analyzing changes in error messages password recovery facilities, again, as an attacker/pentester you&#39;re exploiting differences in the application response. Typically we find a <strong>Forgot password</strong> feature that allows you to receive an email with a new password (or a link that allows you to set a new password). All the user usually needs to do is enter his username or email address.  Now, sometimes the email address is used as the username to log into the application. In fact, this is the case on most e-cart sites. Designing the application to use the user&#39;s email address as the username is common because it&#39;s less likely for someone to forget his email address than a login name.</p>
<div class="message">Remember: there many web applications that allow users to set their username to something different to their email address. Thus, making automated username enumeration more feasible.</div>

<p>A password recovery facility that is vulnerable to username enumeration (most of them out there are) might return an error message like the following when entering an email address that does <em>not</em> exist:</p>
<blockquote>
<p>Sorry, the email address entered does not exist.</p>
</blockquote>
<p>On the other hand, entering a <em>valid</em> email address would look like similar to this:</p>
<blockquote>
<p>A new password has been sent to your email address.</p>
</blockquote>
<p>In short, this method for enumerating usernames is good as a last resort, because <em>most</em> web applications allow usernames to be enumerated through the password recovery facility. However, from the stealth point of view, this is the worst way to enumerate usernames. Think about it, if you <em>do</em> successfully enumerate a valid username, the target account&#39;s owner will get an email with a new password. This is pretty noisy, since you&#39;re telling the victim user: &quot;Hey, I&#39;m probing your account!&quot;. Even worse, sometimes these reset password emails will include your browser&#39;s User-agent header value plus the source IP address that was used to request a new password! Not that I am saying that it is not possible to hide your POP.</p>
<p>Let&#39;s now talk about the third method for enumerating usernames: analyzing changes in error messages on account signup facilities. This method is great for three reasons:</p>
<ul>
<li>it always works! (provided that an account signup facility exists)</li>
<li>the victim user won&#39;t know his/her account is being probed (no emails sent to the victim user for instance)</li>
<li>account lockout policies won&#39;t disable the target account no matter how many times we probe a given username</li>
</ul>
<p>Again, this is the same old story. We send a request, in this case typically through a form to register a new account. If the account signup facility is vulnerable to username enumeration, we will get an error message similar to the following when entering an existing username (login name/email address):</p>
<blockquote>
<p>Sorry, there is already an account registered with the same email address.</p>
</blockquote>
<p>Otherwise, if the entered username does <em>not</em> exist, the account signup process will proceed to the next step (if any), or simply finish successfully.</p>
<div class="message">I recently came across an interesting example while performing a [PCI DSS](https://www.pcisecuritystandards.org/tech/) test at [work](http://www.procheckup.com/). In this case, we were testing an online retailer, and performed a proof-of-concept username enumeration attack against the account signup facility. The result was quite successful since we enumerated more than 600 usernames. Eventually we cracked about 40 accounts by simply bruteforcing a few common passwords against each of the usernames we had enumerated previously. This case was particularly interesting because the site allowed users to change their login name from their email address to any value of their choice. Since many users chose dictionary words, digits, three-letter long and other predictable strings as their usernames, the results were more effective than expected.</div>

<p>If you are a developer you might be wondering how you can protect your site against this kind of attack. Well, although it&#39;s virtually impossible to make an account signup facility immune to username enumeration, it is however possible to avoid <em>automated</em> username enumeration attacks against it by implementing a <a href="http://en.wikipedia.org/wiki/Captcha">CAPTCHA</a> mechanism.</p>
<p>Finally, the last method to enumerate usernames is probing existing URIs. I haven&#39;t seen this work on high-profile web applications, but it should be mentioned nevertheless. Let&#39;s say that the there is a portal hosted on <code>https://acme-site.com/</code> that is used by employees of <em>acme</em>. In this portal, a different directory is assigned to each user&#39;s home page. For instance, for the username <em>victimuser</em> there will be a directory called <code>/webhome/victimuser/</code>.</p>
<p>If the web server responds differently when requesting existing directories, then we can enumerate usernames. For instance, it is very common to see web servers return <code>403 Forbidden</code> error codes when trying to access a directory that exists, but the user is not allowed to access. Otherwise the server would usually return a <code>404 Not Found</code> error code.</p>
<p>Think of <a href="http://del.icio.us/">del.icio.us</a> for instance. Every user is allocated an URI equals to his/her username. For instance, if your username is hacker, then the URL <code>http://del.icio.us/hacker/</code> will exist. On the other hand, if the username probed does <em>not</em> exist (i.e.: <code>http://del.icio.us/madeupusername/</code>), the server might respond with a <code>404 Not Found</code> error code. Of course, because of the nature of del.icio.us, this is not a big deal. After all, the site only provides a public bookmarking service, so no sensitive data is at risk.</p>
<p>As a final note, let me say something about webapps that use email addresses as login names/usernames. In this cases you might think that it&#39;s pretty pointless to find a username (email) enumeration vulnerability. After all, how likely is it that you will find a valid email address since, not only you need to guess the username (i.e.: targetuser), but also the domain name (i.e.: <code>targetuser@acme-shopping.com</code>). Well, the truth is that some sites do actually have test accounts and sometimes even administrative accounts that authenticate through the <em>same</em> login page as regular users. In these cases I always try common usernames with a domain equals to the site that I&#39;m pentesting. In other words, if you are testing a site called <code>www.acme-shopping.com</code>, you should try to enumerate usernames such as <code>test@acme-shopping.com</code>, <code>support@acme-shopping.com</code>, <code>admin@acme-shopping.com</code>, <code>acmeadmin@acme-shopping.com</code> and so on.</p>
<p>You should also search on public websites, maillists and groups for email addresses that use the target domain. An email harvesting tool might come handy in this case. Even if you know that regular users login using email addresses as usernames, you should also try common usernames <em>without</em> appending <code>@acme-shopping.com</code>, as you never know what could work.</p>
<p><em>I hope you found this post useful. I might do a second part that deals with exploiting username enumeration vulnerabilities as opposed to probing/identifying them.</em></p>
</div><div id="post-comments"><p><em>Archived Comments</em></p><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/bd38ec8896a46f6a173c7b80aac0d5be?s=256&amp;d=retro" alt="Jordan"><span class="post-comment-author">Jordan</span><div class="post-comment-content">Thanks for the writeup -- one note about the third method of using account signup forms.  It seems that another prevention mechanism besides CAPTCHAS would be to make the check if the account name is taken the very last step in the signup process, so if the account doesn't exist, you've just created the account.  Combine that with log monitoring such that any single IP can only sign up for x number of new accounts in y minutes.  Sure, somebody could come at you with a botnet, but it's a lot harder to create and distribute an automated probing tool to a botnet than it is to run it on a single attacking server.  Plus, as a last resort, you could always throw on system-wide thresholding for new accounts created so that an admin can get an email and determine whether or not the new accounts are the result of, say, a slashdotting, or just a bot trying to brute-force account names.

Alternatively, you could not tell users about the account name collision until /after/ they've signed up.  Make the next page after the initial account activation or password reset (via email) let them know if there's a collision.  That raises the bar yet again for an attacker to try to enumerate the accounts because he's got to have a lot of valid email addresses now and an automated way to check them as a part of the brute forcing process.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/2736c183681a3d436f70b9f5fd0e5500?s=256&amp;d=retro" alt="Sergey Gordeychik"><span class="post-comment-author">Sergey Gordeychik</span><div class="post-comment-content">Another good example of information leakage via error message is Oracle isqlplus (inurl:/isqlplus intitle:Release).
If you specify wrong Connection Identifier (SID) you got ORA-12154 error, in other case - ORA-01017: invalid username/password</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/d5fd00f741981af1a4c9c779b79aec2a?s=256&amp;d=retro" alt="naka"><span class="post-comment-author">naka</span><div class="post-comment-content">The way to avoid the third method on account signup facilities is to implement CAPTCHA, right? Is it an only counter measure? CAPTCHA is an obstacle for handicapped people. So it is difficult to avoid this vuln on a site which have an account signup facility. I think that the level of importance of this vul is low in most cases. If an adequate counter measure is not available, what do you say to a website owner (your customer)?</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/ef14ae4ef69235fa6c3709438357819d?s=256&amp;d=retro" alt="Adrian Pastor"><span class="post-comment-author">Adrian Pastor</span><div class="post-comment-content">naka,

I'm guessing that when you say handicapped people, you mean people with sight problems. In this case, I would think that applications like Windows magnifier would be more than enough to read the CAPTCHA.

On the other hand, if the handicapped person was completely blind, then there would be a problem since voice synthesizers wouldn't be able to pick up the text in the CAPTCHA.

Interesting point though.

Regarding the importance of this vuln, it really depends on the nature application and the privilege of the username that has been enumerated. Username enumeration does nothing but help you when cracking accounts. I've historically considered this type of vulnerability almost useless, but like everything in this field, when you push the limits and get successful results you change your mind completely.</div></div><div class="post-comment"><img class="post-comment-avatar" src="//gravatar.com/avatar/dd3058ffc10ea3fceee9c51796ed3b15?s=256&amp;d=retro" alt="Idetrorce"><span class="post-comment-author">Idetrorce</span><div class="post-comment-content">very interesting, but I don't agree with you 
Idetrorce</div></div></div></div></article><footer id="footer"><p>Copyright &copy; 2024 <a href=""></a>. All rights reserved.</p></footer></body></html>