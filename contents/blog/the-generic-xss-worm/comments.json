[
  {
    "author": "ntp",
    "avatar": "e9e7690eccc0e9b2ab8ec6a375c96bbd",
    "date": "2007-06-22T22:02:02.000Z",
    "content": "Browser developers should build anti-XSS, LocalRodeo, content-restrictions, and SafeHistory/SafeCache concepts into the browser. Someone (preferably browser developers, but could be administrators) should separate browser profiles (different process id's) into at least two separate browsers / browser profiles:\r\n\r\n1) Firefox for the Internet - will not connect to RFC1918\r\n2) Firefox for your Intranet - will only connect to RFC1918\r\n\r\nJeremiah Grossman suggested a way to make this more transparent, but I suggest this stricter method.\r\n\r\nVulnerability hunters should disclose responsibly to security, cert, noc, hostmaster, postmaster, and webmaster email addresses at top-level domains, preferably to someone who has a GPG public key available in a key server (or use something similar like Hushmail or IBE).  They should also check for any incident response policies and vulnerability reporting processes the organization or website owner may already have in place.  There is no reason to go to another source or through an intermediary.  If all email bounces or there is no response in two weeks, vulnerability hunters should try calling a person by acquiring a phone number of an appropriately titled employee on jigsaw.com, spoke.com, or linkedin.com or from whois as a last resort.  If you can find an XSS, you should know how to social engineer or footprint an email address and phone number.\r\n\r\nAdministrators should respond to and fix problems within 2 weeks (XSS moves faster than buffer overflows) or full-disclosure is fully appropriate.  Like I've said before - if administrators can respond to an SSL certificate expiring within 2 weeks - then they can also respond to an XSS finding in the same amount of time.  The vulnerability researcher can then co-ordinate a fix/disclosure schedule with the vendor and should provide remediation support if necessary.  If you can find an XSS with a scanning tool, you should learn how to fix them for others.\r\n\r\nIT administrators for users should setup the ability to whitelist URL's (e.g. http://whitetrash.sf.net ) if they think their environment can support it.  They should also ensure OS, browser, and browser plugin automatic updates.  Administrators should scan and patch, just like regular vulnerability management.  Good administrators will enforce use of a safe browser similar to the one described in my first paragraph.\r\n\r\nMost importantly, developers should respond to issue tracking about XSS findings (reported by the administrators / operators) immediately as the highest priority... higher than application availability issues (24x7x365).  They should always use validators that are built into their framework properly.  Before coding anything, they should have an enforceable coding standard built into their IDE.  They should use source and static-file code checkers in their IDE.  They should use source checkers (again), static-file checkers (again), and path/code coverage tools (e.g. concolic unit testing) that run fuzz testing across all inputs at build time, including on dependencies.  They should combine model checkers and continuous integration tools (especially build schedulers), ensuring a clean release.\r\n\r\nApplications should be monitored for security events using application monitoring tools (not network security tools or log management tools) by both operators/administrators and developers.\r\n\r\nWeb Application Security Scanners and Web Application Firewalls are OPTIONAL but NOT REQUIRED.\r\n\r\nI refer to this strategy as NTPolicy.  You may use or change it however you like."
  },
  {
    "author": "pdp",
    "avatar": "c4db4e65c9f09f2a373fcaefa5e2bfb4",
    "date": "2007-06-23T07:35:18.000Z",
    "content": "ntp, that was great comment.\r\n\r\nIMHO, things are a bit more complicated. You say:\r\n\r\n<blockquote>Before coding anything, they should have an enforceable coding standard built into their IDE. They should use source and static-file code checkers in their IDE. They should use source checkers (again), static-file checkers (again), and path/code coverage tools (e.g. concolic unit testing) that run fuzz testing across all inputs at build time, including on dependencies. They should combine model checkers and continuous integration tools (especially build schedulers), ensuring a clean release.</blockquote> \r\n\r\nOf course, this is the way forward. However, scripted languages are very hard to automatically examine them, mainly because they are nothing like compiled languages. Most of the IDEs that I've seen which have these types of facilities work only for .NET or Java and nothing else is supported. Although it may seams that most corporate applications use something like that, the truth is that there are a plethora of things that cannot be easily ignored.\r\n\r\nBut yes, you are right. We should do it."
  },
  {
    "author": "david.kierznowski",
    "avatar": "1d95d2324345e3dd2e41d6066cc1b492",
    "date": "2007-06-23T13:31:01.000Z",
    "content": "I don't think there is a clean cut solution right now, we are in for the long-haul."
  },
  {
    "author": "ntp",
    "avatar": "e9e7690eccc0e9b2ab8ec6a375c96bbd",
    "date": "2007-06-25T15:58:53.000Z",
    "content": "<blockquote>Of course, this is the way forward. However, scripted languages are very hard to automatically examine them, mainly because they are nothing like compiled languages. Most of the IDEs that Iâ€™ve seen which have these types of facilities work only for .NET or Java and nothing else is supported. Although it may seams that most corporate applications use something like that, the truth is that there are a plethora of things that cannot be easily ignored.</blockquote>\r\n\r\nScripting languages have one great aspect: they are focused on Test-Driven Development (TDD) to \"get all the bugs out\".  This is fast, works extremely well, and \"drives\" development to the end goal.\r\n\r\nUnfortunately, tested code is not the end goal.  Also - even more extremely unfortunately - DFT (Design for Test) gets skipped.  How could Agile developers skip the most important part?  Well, I guess they don't call them script kiddies for nothing!  Also see: http://www.jwz.org/doc/cadt.html\r\n\r\nAlthough I would argue that \"testing is fun\", especially when you find security-related bugs or flaws.\r\n\r\nMicrosoft uses the SDL, which is largely a waterfall model.  The end goal of the SDL is security.  Microsoft actually has a better model, where the end goal is everything everybody really wants.  It's called Design for Operations (DFO) http://www.codeplex.com/dfo/\r\n\r\nUnfortunately, tools like VSMMD for DFO only leak out from Microsoft once every two to ten years, and usually in crippled form.  Their internal tools such as PreSharp (source checker for C#), FxCop (static file checker for CLR), Magellan (code coverage), and FuzzGuru (path/code coverage with fuzz testing) - as well as their internal coding standards (esp/espx) are not well-known.  Sure, they do have some public tools (that still require VS 2k5/2k8) for coding standards, SAL  annotations, and model checking (AppVerif).  But let's take a look at what Java offers all as open-source.\r\n\r\nJava, with Eclipse plugins, supports CheckStyle, FormatOnSave, and many other options for enforcing a particular coding standard.  Source checkers (PMD, Jlint, Hammurapi), and static-file checkers (FindBugs, SofCheck) are available both in the IDE and in the build tools (e.g. Ant, Maven2, etc).  Model checkers such as Java PathFinder, have some amazing capabilities - and even the Java-specialized tools for CI and build automation (e.g. Luntbuild) are quite complete for this type of work.\r\n\r\nScripters can do the same (Groovy especially), but Ruby, Python, and probably even PHP can have a more planned/focused development model and use the right tools.  It's not just Java and .NET."
  },
  {
    "author": "ntp",
    "avatar": "e9e7690eccc0e9b2ab8ec6a375c96bbd",
    "date": "2007-06-25T16:10:09.000Z",
    "content": "Oh I forgot to add Java code coverage tools such as EMMA (and EclEmma for Eclipse) and the combined path/code coverage tool with fuzz testing (jCUTE).\r\n\r\nNote that Ruby has rcov for code coverage and supports many build options with rake."
  },
  {
    "author": "David",
    "avatar": "a49d504d79a751345bf67be81688d007",
    "date": "2008-01-17T08:32:35.000Z",
    "content": "Guys, great thanks for sharing this info. Could anybody tell me does XSIO - Cross Site Site Image Overlaying still working in social resources like myspace, digg etc? I tried to find this vuln, but i couldn't.. :("
  },
  {
    "author": "pdp",
    "avatar": "c4db4e65c9f09f2a373fcaefa5e2bfb4",
    "date": "2008-01-17T08:52:18.000Z",
    "content": "David, they are aware of the technique so I guess it will be harder."
  }
]