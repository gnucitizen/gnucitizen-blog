[
  {
    "author": "David Kierznowski",
    "avatar": "1d95d2324345e3dd2e41d6066cc1b492",
    "date": "2008-04-05T00:15:49.000Z",
    "content": "Hugo sent me an interesting point regarding the urldecode() attack. I mentioned that urldecode would change <code>%2527</code> to <code>% + 27</code>.\n\n<blockquote>Hugo: The Webserver will change %25 to %, and then urldecode() will change %27 to \"'\".</blockquote>\n\nLets try this out:\n\n<pre><code>$a = $_GET['t'];\n\n    echo $a; // before urldecode\n    $b = urldecode($a);\n    echo $b; // after urldecode\n\nWe get from t=%25 | t=%:\n    $a = %\n    $b = % // no change</code></pre>\n\nThanks for the observation Hugo. \n\nWhile we are on the subject of <code>urldecode()</code>. <code>urldecode()</code> is also vulnerable to NULL byte injection. So there is certainly potential for other vulnerabilities such as File Include bugs (<code>%2500</code>)."
  },
  {
    "author": "Awesome AnDrEw",
    "avatar": "5e0f595cbc8f1811233adce10ac6c5d3",
    "date": "2008-04-05T05:21:20.000Z",
    "content": "Correct me if I'm wrong, David, since I am in no way an expert in PHP, but nullbytes can easily be detected with preg_match and preg_match_all assuming they are in a Hex-encoded string, right? I've experimented with it a bit in the past, and always found it work in my test cases."
  },
  {
    "author": "Gustavo Cardial",
    "avatar": "d5336d69ae0d217a290061546069991b",
    "date": "2008-04-06T00:09:18.000Z",
    "content": "Very nice, I'll check it out! Also, if you know where to find the php sockets presentation, please, let me know"
  },
  {
    "author": "Joey",
    "avatar": "38ae4d6871eaa03293d6fcaba765bb41",
    "date": "2008-04-06T02:20:16.000Z",
    "content": "Thanks for publishing your presentation David. Always good to have more documented vulnerabilities (and their solutions) to keep newly built applications on top of them."
  },
  {
    "author": "hadaka-sarutobi",
    "avatar": "43c7e8b930c2f649e8f866fc336a095e",
    "date": "2008-04-08T01:36:40.000Z",
    "content": "Can you elaborate more on multi-byte encoding attacks and how one attacks/defends them?"
  },
  {
    "author": "mike",
    "avatar": "7cedb843eb2922000eb41b4561ed660d",
    "date": "2008-04-08T23:34:34.000Z",
    "content": "Wow,  its cool to see some CVE's instead of just theory.   I am not saying that I don't enjoy theory. \r\n\r\nurldecode() isn't the only way to bypass filtering.  I used base64_decode() here to bypass magic_quotes_gpc to hit some nifty SQL injection.  The SQL payload I used is a bit different from the norm. http://milw0rm.com/exploits/4733\r\n\r\nAlso EVERY file function in php suffers from a null byte issue because they are all calling the same C file handling function,  go ahead look at the stack trace in GDB.   To be honest as a C programmer I'm horrified some functions will read past the null byte. \r\n\r\nPeace"
  },
  {
    "author": "David Kierznowski",
    "avatar": "1d95d2324345e3dd2e41d6066cc1b492",
    "date": "2008-04-14T10:34:18.000Z",
    "content": "Awesome AnDrEw, as far as I know, I think this is one way to handle NULL bytes.\r\n\r\nhadaka, I could probably do a seperate presentation on that topic. See Awesome AnDrEw's comment.\r\n\r\nmike, cool stuff man. Keep up the good work."
  },
  {
    "author": "Viz",
    "avatar": "b151117078db57b824b1f6710d791db1",
    "date": "2008-04-15T22:54:19.000Z",
    "content": "There is an issue on slide 12 with \n\n<pre><code>POST http://192.168.1.4/t/xoops-2.0.14/htdocs/install/index.php HTTP/1.1\nlang=../../../../../../../../etc/passwd%00&op=start&submit=Next</pre></code>\n\n<blockquote>NOTE: This attack will not work if MAGIC QUOTES are enabled. MAGIC\nQUOTES escapes null characters to . This feature is often forgotten about.</blockquote>\n\nmagic quotes is deprecated and will be going completely away with php 6. Advising people to use it is setting them up for trouble.\n\nper the manual: http://www.php.net/manual/en/security.magicquotes.php\n\n<blockquote>Warning\n\nThis feature has been DEPRECATED and REMOVED as of PHP 6.0.0. Relying on this feature is highly discouraged.</blockquote>\n\nAs well it's inconsistent and doesn't always work. They are removing it because they've realized you can't create defensive coding with a language option that only works half the time. It simply doesn't work. A far better solution to the include problem is to compare the input variable and switch on it:\n\n<pre><code>$var=$_GET['language'];\nswitch($var)\n{\n  case \"english\":\n    $include='english.php';\n    break;\n  case \"spanish\":\n    $include='spanish.php';\n    break;\n  default:\n    $include='genericerror.php';\n    //or even 'english.php'\n}</code></pre>\n\nYou could also set up an associative array of include directories and do an array reference using $var as the index to locate a path or something. If the value at that index is empty (unexpected/malicious input) use the safety include. Using input directly, no matter how it's filtered, to build a path is very very bad form. Always has been. I've lost track (I'm sure you have too 8) of the number of vulnerabilities caused by this type of stupidity. As well, you can use a whitelist filter on your input to remove things like null. eg:\n\n<pre><code>$inputvar=$_GET['inputvar'];\n$inputvar=preg_replace(\"/^[\\w\\.\\@]/\",\"\",$inputvar);\n(remove all but a-z,A-Z,0-9, . and @)</code></pre>\n\nTrying to filter all the bad stuff out is a losing proposition, much better to *only allow the good stuff*. It's future proof.\n\nGreat article!!!\n\n-Viz"
  }
]